# 1. 线程的 run() 和 start() 有什么区别？
* 每个线程都是通过特定的 Thread 对象所对应的 run() 方法来完成操作的，run() 方法称为线程体；通过调用 Thread 类的 start() 方法来启动一个线程。
* strat() 方法用来启动线程，run() 方法用于执行线程运行时的代码。run() 方法可以重复调用，start() 只能调用一次。
* start() 方法启动一个线程，真正实现了多线程运行。调用 start() 方法无须等待 run 方法体代码执行完毕，可以直接执行其他的代码，此时线程处于就绪状态，并没有运行；
然后通过此 Thread 类的 run() 方法来完成其运行状态；run() 方法运行结束，此线程终止，CPU 继续调度其他线程。
* run() 方法时存在于线程内的，只是线程里的一个函数，若直接调用 run() 则相当于直接调用了一个普通函数，而不是多线程的。直接调用 run() 方法必须等待 run() 方法体执行完毕才能执行下面的代码，故执行路径还是只有一条，不存在线程的特征。
所以在执行多线程时要使用 start() 方法而不是 run()。
  
# 2. 为什么调用 strat() 方法时会执行 run() 方法？为什么不直接调用 run() 方法？
new 一个 Thread，此时线程进入了新建状态。调用其 start() 方法，会启动一个线程并使该线程进入就绪状态，当分配到的时间片后就可以开始运行了。
运行阶段，start() 会执行线程相应的准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。

直接执行 run() 方法，会将 run() 方法作为 main 线程下的一个普通方法去执行，并不是开启某一个线程去执行，故并不是多线程工作。

# 3. Sychronized 的原理是什么？
sychronized 又叫做内置锁，因为使用 sychronized 加锁的同步代码块在字节码引擎中执行时，实际上是通过锁对象的 monitor 的取用与释放来实现的。
monitor 内置于任何一个对象，sychronized 利用 monitor 来实现加锁解锁，因此又称为内置锁。

也正因于此，锁对象可以是任意对象：
* sychronized(lock) 加锁时，用到的是 lock 对象内置的 monitor
* 一个对象的 monitor 是唯一的，相当于一个唯一的许可证，获取许可证的线程才可以执行，执行完毕后释放对象的 monitor 后，该 monitor 才能被其他的线程获取

sychronized 加锁的同步块的执行过程：
```java
// 现在假设有代码块：  
    syncrhoized（Object lock）{
        同步代码...;
    }
// 它在字节码文件中被编译为：
    monitorenter; // 获取monitor许可证，进入同步块
    同步代码...
    monitorexit; // 离开同步块后，释放monitor许可证
```


# 4. JVM 对 Java 的原生锁进行了哪些优化？
* 自旋锁：在线程进行阻塞的时候，先让线程自旋等待一段时间，可能在这段时间里其他线程已经解锁，这时就无需再让线程进行阻塞操作了(自选的默认次数是 10)。
* 自适应自旋锁：自旋锁的升级，自旋的次数不在固定，由前一次的自旋次数和锁拥有者的状态决定。
* 锁消除：在动态编译同步代码块的时候，JIT 编译器借助逃逸分析技术来判断锁对象是否只能被一个线程访问，如果是则可以取消锁。
* 锁粗化：当 JIT 编译器发现有一系列的操作都是对同一个对象反复的加锁与解锁，此时会将加锁同步的范围粗化至整个操作系列的外部。

# 5. 为什么 wait()、notify()、notifyAll() 必须在 Object 类中定义？
Java 中，任何对象都可以作为锁，wait() 方法和 notify() 方法用于等待对象的锁或者唤醒线程；在 Java 线程中并没有可供对象使用的锁，故任意对象调用方法一定定义在 Object 类中。

有人说既然是线程放弃对象锁，那可以把 wait() 方法定义在 Thread 类中，新定义的线程继承于 Thread 类，也不需要重新定义 wait() 的实现。但是这种设计存在一个问题：
一个线程可以持有多个锁，而当线程放弃锁的时候就无法判断到底要放弃哪个锁，所以管理起来更加复杂。

# 6. Java 中如何实现多线程之间的同步协作与通信协作？






















