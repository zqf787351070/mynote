# 1. 线程的 run() 和 start() 有什么区别？
* 每个线程都是通过特定的 Thread 对象所对应的 run() 方法来完成操作的，run() 方法称为线程体；通过调用 Thread 类的 start() 方法来启动一个线程。
* strat() 方法用来启动线程，run() 方法用于执行线程运行时的代码。run() 方法可以重复调用，start() 只能调用一次。
* start() 方法启动一个线程，真正实现了多线程运行。调用 start() 方法无须等待 run 方法体代码执行完毕，可以直接执行其他的代码，此时线程处于就绪状态，并没有运行；
然后通过此 Thread 类的 run() 方法来完成其运行状态；run() 方法运行结束，此线程终止，CPU 继续调度其他线程。
* run() 方法时存在于线程内的，只是线程里的一个函数，若直接调用 run() 则相当于直接调用了一个普通函数，而不是多线程的。直接调用 run() 方法必须等待 run() 方法体执行完毕才能执行下面的代码，故执行路径还是只有一条，不存在线程的特征。
所以在执行多线程时要使用 start() 方法而不是 run()。
  
# 2. 为什么调用 strat() 方法时会执行 run() 方法？为什么不直接调用 run() 方法？
new 一个 Thread，此时线程进入了新建状态。调用其 start() 方法，会启动一个线程并使该线程进入就绪状态，当分配到的时间片后就可以开始运行了。
运行阶段，start() 会执行线程相应的准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。

直接执行 run() 方法，会将 run() 方法作为 main 线程下的一个普通方法去执行，并不是开启某一个线程去执行，故并不是多线程工作。

# 3. Sychronized 的原理是什么？


# 4. JVM 对 Java 的原生锁进行了哪些优化？
* 自旋锁：在线程进行阻塞的时候，先让线程自旋等待一段时间，可能在这段时间里其他线程已经解锁，这时就无需再让线程进行阻塞操作了(自选的默认次数是 10)。
* 自适应自旋锁：自旋锁的升级，自旋的次数不在固定，由前一次的自旋次数和锁拥有者的状态决定。
* 锁消除：在动态编译同步代码块的时候，JIT 编译器借助逃逸分析技术来判断锁对象是否只能被一个线程访问，如果是则可以取消锁。
* 锁粗化：当 JIT 编译器发现有一系列的操作都是对同一个对象反复的加锁与解锁，此时会将加锁同步的范围粗化至整个操作系列的外部。

# 5. 为什么 wait()、notify()、notifyAll() 必须在同步方法或同步代码块中使用？

