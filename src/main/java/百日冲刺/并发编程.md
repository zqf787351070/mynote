# 1. 简单说一下对进程和线程的理解？

![并发编程02.png](./picture/并发编程02.png)

* 进程：一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程。在 Windows 系统中，一个运行的 XXX.exe 就是一个进程。
* 线程：进程中的一个执行任务(控制单元)，主要负责当前进程中程序的执行。一个进程至少有一个线程，多个线程可以共享数据。

形象比喻：进程 --> 火车；线程 --> 车厢。

## 1.1 追问：进程和线程有哪些区别？
* 进程之间不会相互影响；而一个线程挂掉会导致整个进程挂掉 (一辆火车故障不会导致另一辆火车故障；而火车中的一节车厢故障将导致整个火车故障)；
* 进程可以拓展到多机；线程最多扩展到多核 CPU (不同的火车可以在不同额轨道上行驶，同一火车的车厢不能行进在不同的轨道上)；
* 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等待它使用结束，才能使用这一块内存 (火车上的洗手间 -- 互斥锁)；
* 进程使用的内存地址可以限定使用量 (火车上的餐车，最多只允许有限个人进入，满了就需要等待有人出来在进去 -- 信号量)；

# 2. 守护线程和用户线程有什么区别？
* 用户线程：运行在前台，执行具体的任务。如程序的主线程、连接网络的子线程等都是用户线程。用户线程独立存在，不会因为其他用户线程退出而退出。
* 守护线程：运行在后台，为其他非守护线程服务。当所有的用户线程都运行结束时，守护线程随着 JVM 一起结束工作。守护线程依赖于用户线程，当所有用户线程都退出了，守护线程才退出。典型的守护线程如垃圾回收线程。

注意事项：
* setDaemon(true) 必须在 start() 方法之前执行，否则会抛出 IllegalThreadStateException 异常；
* 守护线程中产生的新线程也是守护线程；
* 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑；
* 守护线程中不能依靠 finally 代码块来确保代码一定执行。因为守护线程随着用户线程的结束而结束，故 finally 代码块可能不会被执行；

# 3. 什么是线程死锁？
死锁是指两个或者连个以上的线程在执行过程中，由于资源的竞争或者彼此的通信而造成的一种阻塞现象，若无外力作用他们将永远无法推进任务。
此时成系统处于死锁状态，这些永远相互等待的线程称为死锁线程。

个人理解：凡凡拿着杯子想要从水壶倒水喝；楠楠拿着水壶想要倒水到杯子里喝。导致两个人一直等待下去，谁也喝不到水。

死锁示意图：

![并发编程03.png](./picture/并发编程03.png)

## 3.1 追问：形成死锁的四个必要条件是什么？

| 条件 | 描述 |
| --- | --- |
| 互斥 | 某种资源只允许一个线程访问。某资源一旦分配给某一个线程，其他线程便无法再访问，直到占有资源的线程访问结束 |
| 不可抢占 | 某资源已经被占有，需求该资源的线程不可抢夺被占有的资源 |
| 占有且等待 | 一个线程本身占有资源，同时还有资源为得到满足，正在等待其它线程释放该资源 |
| 循环等待 | 每一个线程都占有着其它线程所必须的某些资源 |

上述四个条件全部满足时，必然会造成死锁；若有一个条件不满足，则不会发生死锁。

## 3.2 追问：如何避免死锁？
打破上述的四个必要条件就能有效预防死锁的发生

| 方法 | 描述 |
| --- | --- |
| 打破互斥 | 改造独占性资源为虚拟资源 |
| 打破不可抢占 | 当一个线程占有一个独占性资源而又申请另一个独占性资源但无法得到时，释放原来占有的资源 |
| 打破占有且等待 | 采用资源预先分配策略，在程序运行前申请全部的资源，若满足则运行，不满足则等待，这样就不会一般占有着一边等待其他资源 |
| 打破循环等待 | 实现资源有序分配策略，对线程进行编号，所有线程根据序号递增的形式申请资源 |








































