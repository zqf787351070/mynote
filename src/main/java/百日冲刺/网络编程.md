# 1. 说一下 TCP 连接的三次握手和四次挥手
三次握手：三次握手的本质是确认通信双方(Client/Server)收发数据的能力。建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包，通过这 3 个请求包，来确认双方的接收能力和发送能力是否正常，同时指定自己的初始化序列号为后面的可靠性传输做准备。

三次握手流程图：

![网络编程01.png](./picture/网络编程01.png)

* 第一次握手：客户端将标志位 SYN 置为 1，随机产生一个值 seq = J，将数据包发送给服务端，客户端进入 SYN_SENT 状态，等待服务器端确认。
* 第二次握手：服务器接收到数据包后，由标志位 SYN = 1 得知客户端请求建立连接，服务端将 SYN 与 ACK 都置为 1，ack = J + 1，并随机产生一个值 seq = K，将该数据包发送给客户端以确认连接请求，服务端进入 SYN_RCVD 状态。
* 第三次握手：客户端收到确认后，检查 ack 是否等于 J + 1，ACK 是否为 1，如果正确，则将 ACK 置为 1，ack = K + 1，发送数据包给服务端；服务端接收到数据包，检查 ACK 是否为 1，ack 是否为 K + 1，如果正确则连接建立成功，服务器与客户端进入 ESTABLISHED 状态，完成三次握手，之后客户端与服务器之间就可以开始传输数据了。

四次挥手：需要断开一个 TCP 连接时，服务器与客户端总共要发送 4 个数据包以确认连接的断开。这一过程由客户端或服务端的任一方执行 close 触发。

四次挥手流程图：

![网络编程02.png](./picture/网络编程02.png)

* 第一次挥手：客户端发送 FIN = M，用以关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1 状态。(意思是说我客户端已经没有数据要发送给你了，但是如果你还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据)
* 第二次挥手：服务端收到 FIN 后，先发送一个 ack = M + 1，表明已经收到客户端的断开连接请求。此时客户端进入 FIN_WAIT_2 状态，继续等待服务端的报文。服务端进入 CLOSE_WAIT 状态。
* 第三次挥手：服务端已经确认数据全部发送完毕，向客户端发送 FIN = N，表明数据发送完毕，准备好关闭连接了，服务端进入 LAST_ACK 状态。
* 第四次挥手：客户端收到 FIN = N 的报文，知道可以关闭连接了，便发送 ack = N + 1 给服务端说明已收到，之后进入 TIME_WAIT 状态。如果服务端收到 ACK，就断开连接，客户端等待 2MSL 后依旧没有服务端的回复的话，就说明服务端已经正常关闭，此时客户端即可正常关闭连接。

## 1.1 追问：问什么连接需要三次握手，断开却需要四次挥手？
因为服务端收到客户端发送的 SYN 请求连接报文后，可以直接发送 SYN + ACK 报文，其中 SYN 报文用于同步，ACK 报文用于应答。
而在关闭连接时，服务端收到 FIN 报文后，很可能不会立即关闭 SOCKET，只能先回复 ACK 告知客户端你的请求我收到了。
只有等客户端的所有数据全部发送完毕之后，才能发送 FIN 报文，所以需要四次挥手。
总结来说就是断开连接的时候由任意一方发起，但另外一方此时可能还存在未传送完毕的数据，只有等待数据全部传输完毕才能够断开连接。

## 1.2 追问：如果已经建立了连接，但是客户端突然出现了故障怎么办？
TCP 连接设置有一个保活计时器，如果客户端出现故障，服务端不会一直等待下去白白浪费资源。
服务器每收到一次客户端的请求都会复位这个计数器，该计时器通常设为 2h，若两小时内还没有收到客户端的任何数据，服务器就会发送一个探测报文段，并每隔 75s 发送一次。
如果一连发送 10 个探测报文仍旧没有反馈，那么服务器就认为客户端出现了故障，接着关闭连接。

# 2. 常见的 HTTP 状态码有哪些？

### 状态码的类别
| 状态码 | 状态信息 |
| --- | --- |
| 1XX | informational：信息性状态码 -- 请求正在处理 |
| 2XX | success：成功状态码 -- 请求正常处理完毕 |
| 3XX | redirection：重定向状态码 -- 需要附加操作以完成请求 |
| 4XX | client error：客户端错误状态码 -- 服务器无法处理请求 |
| 5XX | server error：服务器错误状态码 -- 服务器处理请求出错 |

### 2XX 系列状态码
| 状态码 | 状态信息 |
| --- | --- |
| 200 | OK，成功，表示请求在服务端被正确处理 |
| 204 | No content，请求成功但是响应报文不含实体的主体部分 |
| 206 | Partial content，进程范围请求成功 |

### 3XX 系列状态码
| 状态码 | 状态信息 |
| --- | --- |
| 301 | Moved permanently，永久性重定向，表示资源已经被分配了新的 URL |
| 302 | Found，临时性重定向，表示资源被临时分配了新的 URL |
| 303 | See other，表示资源存在着另一个 URL，应该使用 GET 方法获取资源 |
| 304 | Not modified，表示服务器允许访问资源但是请求未满足条件 |
| 307 | Temporary redirect，临时重定向，与 302 类似，但是期望客户端请求方法不变而向新的地址发出请求 |

### 4XX 系列状态码
| 状态码 | 状态信息 |
| --- | --- |
| 400 | Bad request，请求报文存在语法错误 |
| 401 | Unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 |
| 403 | Forbidden，表示请求资源的访问被服务器拒绝，可以在实体的主体部分返回原因描述 |
| 404 | Not found，表示在服务器上没有找到请求的资源 |

### 5XX 系列状态码
| 状态码 | 状态信息 |
| --- | --- |
| 500 | Internal sever error，表示服务端在处理请求时发生了错误 |
| 501 | Not implemented，表示服务器不支持当前请求所需要的某个功能 |
| 503 | Service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 |

# 3. GET 和 POST 请求有哪些区别？
| | GET | POST |
| --- | --- | --- |
| 参数数据类型 | ASCII 字符 | 无限制 |
| 参数长度 | 在 URL 中传送参数的长度是有限制的 | 无限制 |
| 安全性 | 不安全，参数直接暴露在 URL 中，并且会被完整保留在浏览器历史记录中 | 较为安全，参数放在 request body 中 |
| 编码方式| 只支持 url 编码 | 支持多种编码方式 |
| 缓存 | 会被浏览器主动缓存 | 不会被浏览器缓存，除非手动设置 |
| 回退 | 无影响 | 会再次提交请求 |

## 3.1 追问：GET 请求有 Request Body 么？如果有那参数可以像 POST 请求一样放在里面么？
GET 和 POST 在本质上没有区别，都是 HTTP 协议中规定的两种发送请求的方法，底层是 TCP/IP 协议，即他们都是 TCP 连接。
GET 和 POST 能做的事情是完全一样的，在 GET 中加上 Request Body 和在 POST 的 URL 上携带参数，在技术上是完全行得通的。

但是 TCP 协议划分了请求的分类，我们就应该按照规则去使用这些方法。TCP 运输数据，就像一辆辆的货车，如果不进行分类的话，各种货车都是一样的，运作起来一团混乱。
但规定了 GET 类的货车就只能在车顶运输数据；POST 类的货车就只能在车厢中运输数据。各自有各自的功能，这样就显得有条理许多。
当然，如果 GET 想要在车厢里藏些货物，POST 想在车顶堆满货物，也是可以的，但不建议这么做。

## 3.2 追问：URL 中传输的参数的长度有限制么？
之前我们将请求方法比喻成货车，那对应的，客户端和服务端就是运输公司。

理论上来说，我们可以在车顶无限的添加货物(URL 中无线的加参数)，但是运输公司也不傻，装卸货物也需要大量成本，所以他们会限制单次运输量来控制风险，数据量过大对于浏览器和服务器都有很大负担。
大多数浏览器通常会限制 URL 长度在 2K 个字节，大多数服务器最多处理 64K 大小的 URL，超出的部分不再处理。

## 3.3 追问：GET、POST 发送的数据包有什么不同么？
GET 请求时产生 1 个 TCP 数据包；POST 请求时产生 2 个 TCP 数据包。

* GET：浏览器将 http header 和 data 一并发送出去，服务器响应 200
* POST：浏览器先发送 header，服务器响应 100；随后浏览器再发送 data，服务器响应 200

按照之前的思路，GET 请求相当于货车一趟就把货物送到了，而 POST 相当于先跟服务器打个招呼“我又一批货一会送过去”，然后再将货物送出。




















