# 1. 为什么要使用 Redis？哪些业务场景中会使用？
Redis 是目前最为人熟知的缓解高并发、提升高可用能力的手段之一，在提升服务器性能方面效果显著。
在高并发场景下，其核心点在于数据库，引入缓存(或负载均衡、集群等策略)的目的都是在减轻数据库的压力，让更多原本打在数据库上的请求，在中间过程被拦截处理。

Redis 的优势：
* 读写性能优异：读的速度是 110000 次/s，写的速度是 81000 次/s
* 支持数据持久化：支持 AOF 和 RDB 两种持久化方式
* 支持事务：Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的复合操作原子性的执行
* 数据从结构丰富：String、Hash、Set、ZSet、List 等常用数据结构
* 支持主从复制：主机自动将数据同步到从机，可以进行读写分离
* 支持大量集群节点

当用户第一次访问数据库中的某些数据，整个过程会比较缓慢，因为是从硬盘上读取数据。将该用户读取的数据存储到 Redis 中，这样在下一次访问这些数据时就可以直接从缓存中进行读取。
同样的，我们可以直接将数据库中的部分数据转移到缓存当中，这样一部分请求就会直接打到缓存而不会访问数据库。
当数据库中的数据改变后，我们同步的将缓存中的对应数据更新即可。

在日常业务中，例如热点词查询、实时排行榜数据、访问量点赞量统计等场景都可以引入 Redis 进行处理。

## 1.1 追问：Redis 有哪些数据类型？
* String：Redis 中最基本的数据类型，可以理解为与 memcached 一摸一样的数据类型，一个 key 对应一个 value
* Hash：一个 String 类型的 field 与 value 的映射表，适合存储对象，类似于 java 中的 Map<String, Object>
* List：有序的字符串列表，按插入顺序排序，可以选择在头部或者尾部插入，底层实际上是一个链表
* Set：无序的字符串列表，底层通过 HashTable 实现
* Zset：String 类型的集合，不允许存在重复的成员，与 Set 相比，每一个成员关联一个 double 类型的分数

## 1.2 追问：Redis 和 Memcached 有什么区别？

| | Redis | Memcached |
| --- | --- | --- |
| 类型 | 支持内存；非关系型数据库 | 支持内存；键值对形式；缓存形式 |
| 数据类型 | String、Hash、List、Set、Zset | 文本型；二进制类型 |
| 附加功能 | 发布/订阅模式、主从分区、序列化支持、脚本支持 | 多线程服务支持 |
| 网络IO模型 | 单线程的多路 IO 复用模型 | 多线程、非阻塞 IO 模式
| 持久化支持 | RDB/AOF | 不支持 | 
| 集群模式 | 原生支持 cluster 模式，可以实现主从复制、读写分离 | 没有原生集群模式，需要依靠客户端来实现往集群中分片的写入数据 |
| 内存管理机制 | 并不是所有数据都储存在内存中，一些和牛没用的 value 存储在磁盘 | 数据一直储存在内存中，其将内存分割成特定长度的块来存储数据以完全解决内存碎片问题 |
| 使用场景 | 复杂数据结构、有持久化和高可用的需求、value 存储内容较大(最大 512M) | 纯 Key-Value 数据、大数据量、高并发量 | 

核心要点：
* memcached 所有值均为简单的字符串；redis 支持更加丰富的数据结构
* redis 速度比 memcached 快很多
* redis 可以将数据持久化到硬盘，宕机断电可以恢复数据

## 1.3 Redis 如何进行持久化？
* RDB 持久化 (快照)
  * 在某个时间点将所有数据生成快照，存放在硬盘上。当数据量很大时，这个过程很慢
  * 可以将快照复制到其他的服务器从而创建具有相同数据的服务器副本  
  * 若系统故障宕机，将会丢失上一次快照之后所有的数据
* AOF 持久化 (即时更新)
  * 将所有的写命令添加到 AOF 文件 (Append Only File) 的末尾
  * 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘上的时机。这是因为对文件的写操作并不会马上将内容同步到磁盘，而是先存储到缓冲区，然后由操作系统决定何时同步到磁盘。同步频率包括：
      * always：每一个写命令都同步
      * everysec：每秒同步一次(最合适，可以保证服务器崩溃时最多只丢失一秒左右的数据且不会影响服务器性能)
      * no：由操作系统决定何时同步

# 2. Redis 为什么是单线程的？
Redis 官网给出的解释：Redis 的瓶颈不是 CPU 的运行速度，而是网络带宽和机器内存的大小。而且单线程切换开销小，易于实现。一个节点就是一个单线程。

## 2.1 追问：单线程只使用了单核 CPU ，很浪费，有什么办法能发挥多核 CPU 的性能么？
可以通过在单机开多个 Redis 实例来实现。我们所说的单线程，是在处理我们的网络请求时只有一个线程来处理。
实际使用中，一个正式的 Redis Server 运行的时候肯定不知一个线程，都是以集群形式存在的。

# 3. 聊一下你对缓存穿透、缓存击穿、缓存雪崩的理解？
* 缓存穿透：指缓存中和数据库中都没有响应的数据，导致所有的请求都打在数据库上，而数据库还查找不到对应数据，造成数据库在短时间内线程数被打满导致其他服务阻塞，最终导致线上服务不可用，一般这种情况来自黑客攻击。
* 缓存击穿：指缓存中没有但数据库中有的数据(一般是热点数据缓存时间到期)，此时由于并发量较大，同时缓存中又没有读取到数据，所以全部的请求都打在数据库上进行查询，引起数据库压力瞬间增大，线上服务卡住。
* 缓存雪崩：指缓存在同一时间大面积失效，是缓存击穿的升级版。

## 3.1 追问：说一下缓存击穿的解决办法
* 方法1：根据实际的业务情况，在 Redis 中维护一个热点数据表，将其中的数据批量设置为永不过期(如前 1000 的热点数据)，并定时更新 top1000；
* 方法2：添加互斥锁。缓存击穿后，会有多个线程同时去数据库中查询某一个数据，那么我们可以在第一个到达数据库的查询请求上使用互斥锁来锁住它。其他的线程进行到这一步会因为没有获取到锁而阻塞。当第一个线程查询到对应的数据之后，将数据写入缓存。此时其他的请求检查缓存发现已经有响应的数据，便直接从缓存中返回对应数据。

方法2代码流程示例：
```java
    static Lock reenLock = new ReentrantLock();
    public List<String> getData04() throws InterruptedException {
        List<String> result = new ArrayList<String>();
        // 从缓存读取数据
        result = getDataFromCache();
        if (result.isEmpty()) {
            if (reenLock.tryLock()) {
                try {
                    System.out.println("拿到锁了,从DB获取数据库后写入缓存");
                    // 从数据库查询数据
                    result = getDataFromDB();
                    // 将查询到的数据写入缓存
                    setDataToCache(result);
                } finally {
                    reenLock.unlock();// 释放锁
                }

            } else {
                result = getDataFromCache();// 先查一下缓存
                if (result.isEmpty()) {
                    System.out.println("我没拿到锁,缓存也没数据,先小憩一下");
                    Thread.sleep(100);// 小憩一会儿
                    return getData04();// 重试
                }
            }
        }
        return result;
    }
```

# 4. 介绍一下 Redis 的哨兵模式
哨兵模式的介绍：
* Sentinel 进程用于监控 redis 集群中 master 主服务器的工作状态
* 在 master 主服务器发生故障时，可以实现 master 和 slave 服务器的切换，保证系统的高可用

哨兵进程的作用：
* 通过发送命令，让 redis 服务器返回信息监控其运行状态，包括主服务器和从服务器
* 当哨兵检测到 master 宕机，会自动将 slave 转换成 master，然后通过发布订阅模式通知其它服务器，修改配置文件，切换主机
* 可以使用多个哨兵进行监控，各个哨兵之间还可以互相监控，形成多哨兵模式

## 4.1 追问：介绍一下 Redis 故障的自动切换过程
当主服务器宕机是，哨兵 1 首先检测到服务器宕机，但仅仅是哨兵 1 主观认为服务器不可用，这个现象称为主观下线。
当其他的哨兵也检测到主服务器不可用，并且观察到的哨兵的数量达到一定值时，哨兵们就会进行一次投票，并根据投票的结果，由一个哨兵执行，切换主服务器。
切换成功后，就会根据发布订阅模式，让各个哨兵把自己监控的从服务器切换主机，这个过程称为客观下线。

## 4.2 说一下主观下线和客观下线的区别
* 主观下线：指单个 Sentinel 实例对服务器做出下线判断
* 客观下线：指多个 Sentinel 实例对同一个服务器做出主观下线判断，并通过 SENTINEL is-master-down-by-addr 命令相互交流之后，得出服务器的下线判断

从主观下线到客观下线状态的转换并没有使用严格的法定人数算法(strong quorom algorithm)，而是使用了流言协议：
如果 Sentinel 在给定的时间范围内，从其他的 Sentinel 接受了足够数量的主服务器下线报告，那么 Sentinel 就会将主服务器的状态从主观下线转换为客观下线。
如果之后其他的 Sentinel 不在报告主服务器已下线，那么客观下线的状态就会被移除。

## 4.3 说一下哨兵进程的工作方式
* 每个 Sentinel 进程以每秒一次的频率向整个集群中的 master 主服务器、slave 从服务器以及其它的 Sentinel 哨兵发送一个 PING 命令
* 如果某一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 属性所规定的值，则该实例就会被 Sentinel 标记为主观下线
* 如果一个 master 主服务器被标记为主观下线，则正在监视该 master 服务器的所有 Sentinel 都要以每秒一次的频率确认 master 主服务器的确进入了主观下线状态
* 当有足够数量(大于配置中数值)的 Sentinel 进程在指定的时间范围内确认 master 主服务器进入了主观下线状态，则 master 主服务器就会被标记为客观下线状态
* 若没有足够数量的 Sentinel 进程同意 master 主服务器下线，则 master 的客观下线状态就会被移除；若 master 重新向 Sentinel 进程发送有效回复，则 master 的主观下线状态就会被移除

[Redis 哨兵模式的配置方法](https://zqf787351070.github.io/myblog/docs/Service/Redis/06.html)

# 5. Redis 的过期策略和内存淘汰策略是一样的么？
不是的。过期策略主要用于处理过期的缓存数据；内存淘汰策略则用于处理内存不足时的需要申请额外空间的数据。

### 内存过期策略
在 redis 中过期的 key 不会被立即从内存中删除，而是会同时以下列两种策略执行删除：
* 定期删除：每隔一段时间随机检查设置了过期时间的 key 并删除已经过期的 key，该策略维护一个定时器，消耗 CPU 资源；
* 惰性删除：当 key 被访问时检查该 key 的过期时间，若过期则删除，该策略的问题是已经过期但是未被访问的数据仍然保持在内存当中，消耗内存资源；

如果使用定期删除策略漏掉了很多已经过期的 key，这些 key 还没有及时的访问，那么就会有大量过期的 key 保留在内存当中，导致空间占用，此时就需要内存淘汰策略。

### 内存淘汰策略
内存淘汰策略规定了如何淘汰旧数据以为新数据腾出足够的内存空间，其并不会影响过期 key 的处理，其包含下列几个机制：

| 策略 | 描述 |
| --- | --- |
| no eviction | 当内存不足以容纳新写入的数据时，新写入的操作会报错| 
| allkeys-lru | 当内存不足以容纳新写入的数据时，在 key 空间中移除最近最少使用的 key (该策略最常用) |
| allkeys-random | 当内存不足以容纳新写入的数据时，在 key 空间中随机移除某个 key |
| volatile-lru | 当内存不足以容纳新写入的数据时，在设置了过期时间的 key 中移除最近最少使用的 key |
| volatile-random | 当内存不足以容纳新写入的数据时，在设置了过期时间的 key 中随机移除某个 key |
| volatile-ttl | 当内存不足以容纳新写入的数据时，在设置了过期时间的 key 中，有更早过期时间的 key 优先被删除 |

## 5.1 追问：简单介绍一下 LRU 淘汰机制吧
LRU (Least Recently Used) 算法：淘汰最近最少使用的。该算法根据数据的历史访问记录来进行淘汰数据，其核心思想为：如果数据最近被访问过，那么将来被访问的几率也就更高。

算法思路：
* 新数据插入到链表头部
* 每当缓存被命中时，就将该数据移动到链表头部
* 链表满时将链表尾部的数据丢弃

在 Redis 服务其配置中保存了 lru 计数器 server.lrulock，该计数器定时更新，其值是根据 server.unixtine 计算并进行排序，选择最近一次使用时间最久远的数据进行删除。每一个 redis 对象都会设置相应的 lru，每一次访问数据该值都会更新。

在 Redis 中，LRU 算法是一个近似算法，默认情况下 Redis 会随机挑选 5 个键，从中选择一个最久未使用的 key 进行淘汰。
在配置文件中可以配置 maxmemory-samples 项，该项配置的越大，消耗的时间越长，但结构也就更精确。

## 5.2 追问：如果 Redis 的内存耗尽会怎样？
如果达到设置的内存上线，Redis 的写命令会返回错误信息，但是读命令会正常执行返回；如果配置了相应的内存淘汰策略，当内存达到上限时就会冲刷掉旧的内容。

## 5.3 追问：Redis 如何进行内存优化？
尽可能地利用 Hash、List、Set、ZSet 等集合数据类型。尽可能地多使用 Hash，因为其使用的内存很小，所以在设计的时候应该尽量的将数据模型抽象到一个散列表当中。
比如 web 项目中的用户对象，不要为这个用户的用户名、密码、昵称、电话、邮箱等设置单独的 key，而是应该将这个用户的所有信息存储到一张散列表当中。































