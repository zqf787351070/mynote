**JVM**

# 1. 说一下 JVM 的主要组成部分以及作用？
JVM 包括类加载子系统、直接内存、垃圾回收器、执行引擎堆、方法区、栈、本地方法栈、程序计数器：
* 类加载子系统：负责加载 class 信息，加载的类信息放在方法区中
* 直接内存：直接内存是在 Java 堆外的、直接向系统申请的内存空间。访问直接内存的速度会快于 Java 堆。出于性能的考虑，读写频繁的场合可能会考虑使用直接内存
* 垃圾回收器：垃圾回收器可以对堆、方法区、直接内存进行回收
* 执行引擎：执行引擎负责执行虚拟机的字节码，虚拟机会使用即时编译技术将方法编译成机器码之后再执行

下列组成部分为 JVM 运行时数据区：
* 堆：堆解决的是实例对象存储的问题，也是垃圾回收管理的主要区域
* 方法区：方法区可以看作是堆的一部分，用于存储已经被虚拟机加载的信息（常量、静态变量、JIT 编译器编译后的代码）
* 栈：栈解决的是程序运行的问题，栈里面存储的是栈帧，栈帧中存储的是局部变量表、操作数栈、动态链接、方法出口等信息
    * 栈帧：每个方法从调用到执行的过程就是一个栈桢在虚拟机中入栈到出栈的过程
    * 局部变量表：保存函数的参数和局部变量
    * 操作数栈：有关操作数栈的大多数指令都是将数据从这里弹出，然后执行运算后再压回操作数栈
* 本地方法栈：与栈功能相同，本地方法栈执行的是本地方法，是一个 Java 调用非 Java 代码的接口
* 程序计数器： 程序计数器中存放的是当前线程锁执行的字节码文件的行数。JVM 通过改变这个值来选取下一个需要执行的字节码指令

# 2. 什么是类加载器？类加载器有哪些？
类加载器负责加载所有的类，它会为所有被载入内存的类生成一个 java.lang.Class 实例对象。

JVM 有三种类加载器：
* 启动类加载器：该类没有父加载器，其用来加载 Java 核心类，启动类加载器的实现依赖于底层操作系统，须臾虚拟机实现的一部分，它并不继承自 java.lang.classLoader
* 扩展类加载器：其父类为启动类加载器。扩展类加载器是 java.lang.classLoader 类的子类，负责加载 JRE 的扩展项目
* 应用程序类加载器：其父类为扩展类加载器。应用程序类加载器从环境变量 classpath 或者系统属性 java.lang.path 指定的目录中加载类。同时它也是自定义的类加载器的父类。

# 3. 说一下类加载的执行过程
当程序需要使用某一个类但该类还未被加载到内存中时，JVM 会通过加载、链接、初始化三个步骤对该类进行加载：
* 加载：加载指将类的 class 文件读取到内存中，并为之创建一个 java.lang.Class 对象
  * 类的加载阶段又类加载器完成，类加载器由 JVM 提供。开发人员也可以通过继承 ClassLoader 类来自定义类加载器
  * 通过使用不同的类加载器可以从不同的来源加载类的二进制数据，其来源通常有：本地文件系统、jar 包、网络加载、将 java 源文件动态编译并执行加载
* 链接：当类被加载后，系统位置生成一个 Class 对象，然后进入链接阶段，链接阶段负责将类的二进制数据整合到 JRE 当中
  * 验证阶段：进行文件格式验证、元数据验证、字节码验证、符号引用验证
  * 准备阶段：为类的静态变量分配内存，并将其设置为默认初始值
  * 解析阶段：将类的二进制数据中的符号引用替换为直接引用
* 初始化：将类的静态变量赋予正确的初始值

# 4. JVM 的类加载机制是什么？
JVM 的类加载机制可以总结为如下三点：
* 全盘负责：当类加载器加载某一个类时，该类所依赖和引用的其他类也由该类加载器负责载入
* 双亲委派：当类加载器需要加载某一个类时，首先尝试让父加载器去加载，当父加载器无法加载时才考虑自己加载
* 缓存机制：该机制保证所有被加载过的类都会被缓存，当程序需要使用某一个类时，首先再缓存区中进行搜索，如果缓存区中不存在，才回去读取类对应的二进制数据，存入缓存区
这也是为什么修改类之后，必须重启 JVM 才能使修改生效
  
# 5. 什么是双亲委派模型？
如果一个类加载器需要去加载某一个类，它首先将这个类加载的请求委托给父类加载器执行。若父类加载器还存在父类加载器，则进一步向上委托，请求最终到达顶层的启动类加载器。
顶层的类加载器尝试加载该类，若能加载成功，则成功返回；若无法加载该类，则依次向下由子类加载器尝试加载。这个过程即双亲委派模型。

双亲委派模型的优势：
1. 可以避免类的重复加载
2. 可以保证安全性，避免 java 的核心 API 库被替换

# 6. 如何判断对象是否可以被回收？
* 引用计数算法：通过判断对象的引用数量来决定对象是否可以被回收
  * 每一个对象都有一个引用计数器，当其被引用时，计数器 +1；完成引用后计数器 -1。任何引用计数为 0 的对象实例都可以被回收。
  * 优点：执行效率高，程序受影响小；
  * 缺点：无法检测出循环引用的情况，导致内存泄漏。
* 可达性分析算法：通过判断对象的引用链是否可达来决定对象是否可以被回收
  * 如果一个对象不存在到 GC root 跟对象的可达路径，则成该对象不可达。不可达状态的对象实例可以被回收。
  
# 7. 哪些对象再 JVM 中可以作为 GC root 对象？
* 虚拟机栈的栈帧：每一个方法在执行时，JVM 都会对应创建一个相应的栈帧(即操作数栈、局部变量表、运行时常量池的引用)。当方法执行完毕，该栈帧就从虚拟机栈中弹出，此时，方法中临时创建的对象就没有被任何 GC root 引用了，那么这些对象在下一次 GC 时就会被回收。
* 方法区中的静态属性：静态属性不属于任何实例，因此该属性也可以作为 GC root。只要该类的 Class 存在，静态属性引用的对象就一直存在。但是 Class 也会存在被回收的情况：
  * 堆中不存在任何该类的实例对象
  * 加载该类的类加载器 classLoader 已经被回收
  * 该类的 java.lang.class 对象没有在任何地方被引用，即无法通过反射访问该类的信息
* 本地方法栈引用的对象

# 8. 说一下 JVM 有哪些垃圾回收算法？
* 标记清除算法：分两个阶段执行。第一阶段标记所有从 GC root 的引用对象；第二阶段执行未引用对象的清理。该算法会产生内存碎片，如果下次由较大的对象需要在堆上分配较大的内存空间时，可能会因为无法找到足够大的连续的内存空间而再次触发垃圾回收。
* 复制算法(Java 堆中新生代的垃圾回收算法)：该算法分三阶段执行，其将内存空间划分为两个相等的区域，只是用其中的一个来存放对象。第一阶段标记所有不需要回收的内存；第二阶段将所有不需要回收的内存复制到另外一个区域；第三阶段回收全部的原内存区域。通过这个方法克服了内存碎片的问题，但其缺点时损失了部分系统内存。
* 标记整理算法(Java 堆中老年代的垃圾回收算法)：对于新生代，大部分对象不会存活，所以复制算法比较高效；但对于老年代，大部分对象需要继续存活，此时使用复制算法效率较低。标记整理算法首先还是进行标记，将不需要回收的对象压缩到内存的一端，然后清除边界处的内存，通过这个方法避免了复制算法带来的效率问题，同时也避免了内存碎片化的问题。

# 9. 说一下 JVM 有哪些垃圾回收器？
详见 --> [interview JVM 内存机制](https://zqf787351070.github.io/myblog/docs/Interview/04-JVM%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6.html)

# 10. 新生代垃圾回收器和老年代垃圾回收器有哪些？有什么区别？
* 新生代垃圾回收器：Serial、ParNew、Parallel Scavenge，新生代垃圾回收器一般采用复制算法，效率较高但是存在内存的浪费
* 老年代垃圾回收器：Serial Old、Parallel Old、CMS，老年代垃圾回收器采用标记清除算法

# 11. 简单说一下分代垃圾回收的执行流程？
分代垃圾回收器分为新生代和老年代，新生代包括 Eden、From Survivor、To Survivor，其比例为 8 ： 1： 1

垃圾回收器的执行流程：
1. 将 Eden 和 From Survivor 存活的对象放入 To Survivor 区
2. 清空 Eden 和 From Survivor 分区，然后将 To Survivor 区和 From Survivor 区互换
3. 每次交换后存活的对象年龄 +1，年龄到达 15 后升级为老年代，较大的对象会直接放入老年代
4. 当老年代中的空间到达一定的占比后，会触发全局回收

# 11. JVM 中堆栈的概念？对象在何时被销毁？
* 类在程序运行的时候就会被加载，方法则是在执行的时候才会被加载
* 静态变量在类加载的时候创建，在整个程序结束时按序销毁；
* 实例变量在实例化对象时创建，在对象销毁时销毁；
* 局部变量在局部范围内使用时创建，跳出局部范围是销毁；











