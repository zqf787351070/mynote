**Java SE**

# 1. JDK、JRE、JVM 有什么区别？
* JDK：Java Development Kit，Java开发工具包
* JRE：Java Runtime Environment，Java运行环境
* JVM: Java Virtual Machine，Java虚拟机

JDK 中包含 JRE，JDK 中存在一个名为 jre 的目录，其中包含两个文件夹，bin 和 lib。其中 bin 就是 JVM，lib 则是 JVM 所需要的类库。

# 2. == 和 equals 的区别是什么？
* 对于基本类型，== 比较的是值；对于引用类型，== 比较的是地址
* equals 不能用于基本类型的比较。若没有重写 equals 方法，则其等价于 ==；若重写了 equals 方法，则其比较的是对象的内容

# 3. final 关键字的作用？
* final 修饰的成员变量必须在声明的同时赋值，一旦创建其值不可修改
* final 修饰的方法不可被子类重写
* final 修饰的类中的方法默认是 final 的
* private 修饰的方法默认是 final 的

# 4. Java 中 Math 提供的几个取整方法
* ceil(): 向上取整
* floor(): 向下取整
* round(): 四舍五入

# 5. String 属于 Java 的基本数据类型么？
不属于。Java 的基本数据类型包括：byte / short / char / int / float / double / long / boolean

# 6. String str = "i" 与 String str = new String(“i”) 一样吗？
* String str = "i" 会将 str 分配到字符串常量池中。常量池中不存在重复的元素，若常量池中已经存在 “i”，则会将 "i" 的地址赋予 str；若常量池中不存在，就会在常量池中创建一个 "i" 再赋值给 str。
* String str = new String(“i”) 会将 str 分配到堆中，即使存在相同的元素还是会创建一个新的对象

# 7. 如何将字符串反转？
将对象封装到 StringBuilder 中，调用 reverse() 方法进行反转
```java
public class test {
    public static void main(String[] args) {
        String str = "abcdefg";
        StringBuilder stringBuilder = new StringBuilder(str);
        String res = stringBuilder.reverse().toString();
        System.out.println(res);
    }
}
```

# 8. String 类的常用方法有哪些？
* 获取功能
  * length(): 获取字符串长度
  * charAt(int index): 获取指定索引位置的字符
  * indexOf(String str): 返回指定字符在此字符串中第一次出现处的索引
  * substring(int start, int end): 截取字符串  
* 判断功能
  * equals(Object obj): 比较字符串的内容是否相同，区分大小写
  * contains(String str): 判断字符串中是否包含传入的字符
  * startsWith(String str): 判断字符串是否以传入的字符开头
  * endsWith(String str): 判断字符串是否以传入的字符结尾
  * isEmpty(): 判断字符串的内容是否为空  
* 转换功能
  * byte[] getBytes(): 将字符串转换为字节数组
  * char[] toCharArray(): 把字符串转换为字符数组
  * String valueOf(char[] chs): 将字符数组转换为字符串
  * toLowerCase(): 将字符串转换为小写
  * toUpperCase(): 将字符串转换为大写
  * concat(): 拼接字符串  
* 其他常用功能
  * replace(char old,char new): 将指定字符进行互换
  * replace(String old,String new): 将指定字符串进行互换
  * trim(): 去除两端空格
    
# 9.  String str = new String(“a”) + new String(“b”)会创建几个对象？
对象1：new StringBuilder()；对象2：new String("a")；对象3：常量池中的"a"；对象4：new String("b")；对象5：常量池中的"b"；对象6：new String("ab")

## String str = "a"+"b";产生几个对象？
答案是3个，字符串常量区存储"a","b","ab"三个对象

## String str = "a"+new String("b");产生几个对象？
答案是3个，字符串常量区存储"a","b"，堆中存储new String("b")的对象。

# 10. String.intern() 方法
调用这个方法之后就是去看当前字符串是否在常量池中存在
* 存在：那就直接返回该字符串在字符串常量池中所对应的地址给栈中要引用这个字符串的变量。
* 不存在：
  * jdk1.6：先在字符串常量池中创建该字符串，地址与堆中字符串地址不相同。返回值为刚创建的字符串在字符串常量池中所对应的地址给栈中要引用这个字符串的变量。
  * jdk1.7及以后：直接将堆中该字符串的地址复制到字符串常量池中，此时字符串常量池中的字符串只是一个对堆中字符串对象的引用，它们两个的地址相同，然后再将该地址返回给栈中要引用这个字符串的变量。
    
```java
public class StringIntern {
    public static void main(String[] args) {
        String s = new String("1"); // 在堆中和字符串常量池中都创建了该字符串1对象，但它们地址不相同
        s.intern(); // 调用此方法之前，字符串常量池中已经存在了"1"，所以什么也不做
        String s2 = "1"; // 这时在字符串常量池中已经存在1对象了，所以此步只是把new String()在常量池中创建1对象地址赋给s2
        System.out.println(s == s2); // jdk6：false   jdk7/8：false   一个地址是在堆中一个在常量池中肯定不相等

        String s3 = new String("1") + new String("1"); // s3变量记录的地址为：new String("11")
        //执行完上一行代码以后，字符串常量池中，是否存在"11"呢？答案：不存在！！
        s3.intern(); // 在字符串常量池中生成"11"。如何理解：
        // jdk6:创建了一个新的对象"11",也就有新的在常量池中的地址。
        // jdk7:此时常量中并没有创建"11",而是创建一个指向堆空间中new String("11")的地址，两个地址相同
        String s4 = "11"; // s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的"11"的地址
        System.out.println(s3 == s4); // jdk6：false  jdk7/8：true
    }
}
```

# 11. 普通类和抽象类的区别？
* 抽象类不可被实例化
* 有抽象方法的类一定是抽象类；抽象类可以有抽象方法，只需要声明，不需要实现
* 抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类
* 抽象方法不能声明为静态，不能被 final / static 修饰

# 12. 接口和抽象类有什么区别？
* 接口
  * 接口使用 interface 修饰
  * 接口不能被实例化
  * 一个类可以实现多个接口
  * java 8 之前，接口中的方法都是抽象方法；java 8 之后，接口中可以定义静态方法。
* 抽象类
  * 抽象类使用 abstract 修饰
  * 抽象类不能被实例化
  * 一个类只能单继承另一个类
  * 抽象类中可以包含抽象方法和非抽象方法
    
# 13. Java 中的 IO 流分为几种？
* 按流划分，可以分为输入流和输出流
* 按单位划分，可以分为字节流和字符流

# 14. BIO / NIO / AIO 有什么区别？

## 同步与异步
IO 操作主要分为两个步骤，即发起 IO 请求和实际 IO 操作，同步 IO 与异步 IO 的区别就在于第二个步骤是否阻塞。

* 若实际 IO 操作阻塞请求进程，即请求进程需要等待或者轮询查看 IO 操作是否就绪，则为同步 IO。
* 若实际 IO 操作并不阻塞请求进程，而是由操作系统来进行实际 IO 操作并将结果返回，则为异步 IO。

## 阻塞与非阻塞
IO 操作主要分为两个步骤，即发起 IO 请求和实际 IO 操作，阻塞 IO 与非阻塞 IO 的区别就在于第一个步骤是否阻塞。

* 若发起 IO 请求后请求线程一直等待实际 IO 操作完成，则为阻塞 IO。
* 若发起 IO 请求后请求线程返回而不会一直等待，即为非阻塞 IO。

## BIO / NIO / AIO

* BIO 表示同步阻塞式 IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
* NIO 表示同步非阻塞 IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。
* AIO 表示异步非阻塞 IO，服务器实现模式为一个有效请求一个线程，客户端的 I/O 请求都是由操作系统先完成 IO 操作后再通知服务器应用来启动线程进行处理。

举个生活中简单的例子：烧水。小时候你比较笨，在那里傻等着水开（**同步阻塞**）。等你再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（**同步非阻塞**）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情（**异步非阻塞**）。

# 15. Files的常用方法都有哪些？
* `Files.exists()`：检测文件路径是否存在。
* `Files.createFile()`：创建文件。
* `Files.createDirectory()`：创建文件夹。
* `Files.delete()`：删除一个文件或目录。
* `Files.copy()`：复制文件。
* `Files.move()`：移动文件。
* `Files.size()`：查看文件个数。
* `Files.read()`：读取文件。
* `Files.write()`：写入文件。

# 16. 什么是反射？
Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

# 17. 什么是 java 序列化？什么情况下需要序列化？
序列化是一种用来处理对象流的机制。该机制允许将序列化的 Java 对象转换位字节序列，这些序列可以保存在磁盘上或者通过网络传输。序列化机制使得对象可以脱离程序的运行而独立存在。

序列化是通过实现 serializable 接口，该接口没有需要实现的方法，实现该接口只是为了标注该对象是可被序列化的。

一般程序在运行时产生对象，这些对象随着程序的停止而消失。当我们想将某些对象保存下来或者通过网络传输时，需要使用序列化。

# 18. 为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝的区别是什么？

## 为什么使用克隆？
想对一个对象进行复制，又想保留原有的对象进行接下来的操作，此时需要克隆。

## 如何实现对象克隆？
* 实现 Cloneable 接口，重写 clone() 方法
* 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，该方式可以实现真正的深克隆
* BeanUtils，apache，Spring 都提供了 bean 工具，但都是浅克隆

## 深拷贝和浅拷贝的区别是什么？
* 浅拷贝：仅仅克隆基本类型变量，不克隆引用类型变量，即克隆得到的新对象的引用类型变量地址与原对象相同
* 深拷贝：既克隆基本类型变量，又克隆引用类型变量

# 19. throw 和 throws 的区别？
* throw
  * 作用在方法内，表示抛出一个具体异常，由方法体内的语句进行处理
  * throw 表明一定抛出了异常
* throws
  * 作用在方法的声明上，表示可能会抛出异常，该异常需要由调用者进行处理
  * throws 表明可能发生异常，但不一定会发生异常
  
# 20. final、finally、finalize 有什么区别？
* final 可以修饰类，属性，方法。其修饰的类不可被继承，修饰的变量不可被重新赋值，修饰的方法不能被重写
* finally 用于捕捉到异常后的收尾处理，finally 代码块内的语句无论是否发生异常，都会执行，常用于一些流的关闭
* finalize 方法用于垃圾回收。一般情况下不需要我们实现 finalize()，只有当对象被回收的时候需要释放一些资源才会实现。比如 socket 链接，在对象初始化时创建，在整个生命周期内有效，需要实现 finalize() 在其被回收时关闭这个链接

## try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
finally 代码块内的语句一定执行。一般来说的执行顺序为：catch --> finally -- > catch 中的 return

# 21. 常见的异常类有哪些？
* NullPointerException：空指针异常；
* SQLException：数据库相关的异常；
* IndexOutOfBoundsException：数组下角标越界异常；
* FileNotFoundException：打开文件失败时抛出；
* IOException：当发生某种 IO 异常时抛出；
* ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出此异常；
* NoSuchMethodException：无法找到某一方法时抛出；
* ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常；
* NumberFormatException：当试图将字符串转换成数字时失败抛出；
* IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数；
* ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例；

# 22. hashcode() 方法是什么？有什么作用？
是 Object 包含的一个方法，其只要配合基于散列的集合一起使用，比如 HashSet、HashMap、HashTable。
当集合需要添加新的对象时，首先调用这个对象的 hashcode() 方法，获得对应的 hashcode 值，将该值与 hashmap 中存储的对象的 hashcode 作比较（hashmap 维护一个 table 存储所有对象的 hashcode）。
如果 table 中不存在该 hashcode 值，则将该对象存入；如果有，就调用 equals() 方法将两个元素进行比较，不同则存入，相同则不存入。

## equals 和 hashcode 的关系
* 若 hashcode 值相等，则 euqals 不一定为 true；若 hashcode 不相等，则 equals 一定为 false。
* 若 equals 为 true，则 hashcode 一定相等；若 equals 为 false，则 hashcode 不一定相等。

# 23. Java 中操作字符串都有哪些类？他们之间有什么区别？
* String：String 是不可变对象，每次对 String 类型的改变都会生成一个新的对象
* StringBuilder：线程不安全的，效率高，多用于单线程
* StringBuffer：内部加锁，是线程安全的，但效率不如 StringBuilder，适用于多线程

# 24. Java 中都有哪些引用类型？
* 强引用：Java 默认声明的就是强引用（比如 new 生成的对象）。只要强引用存在，垃圾回收器就永远不会回收被引用的对象。若想回收对象，可以将对象设置为 null；
* 软引用：当内存足够时，软引用不会被回收。只有当内存不足时，系统才会回收软引用对象。若回收了软引用对象后，仍然没有足够的内存，则会出现内存溢出异常；
* 弱引用：只要进行垃圾回收，弱引用就会被回收；
* 虚引用
* 引用队列：引用队列可以与软引用、弱引用、虚引用一起配合使用。当垃圾回收器准备回收一个对象时，如果发现其还有引用，就会在回收对象之前，将这个引用放入引用队列当中。
程序可以通过引用队列是否加入了引用，来判断被引用的对象受否将要被垃圾回收，这样可以在对象被回收之前采取一些必要的措施；

# 25. 在 Java 中，为什么不允许从静态方法中访问非静态变量？
* 静态变量属于类本身，在类加载时就会被分配到内存，可以通过类名直接访问；
* 非静态变量属于类的对象，只有当类的对象产生时，才会分配内存，通过类的实例去访问；
  
静态方法也属于类本身，但是此时没有类的实例，内存中没有非静态变量，故无法调用。

# 26. 什么是 Java 内存模型？
为解决并发编程的三大问题（可见性、原子性、有序性），提出了 JSR-133 内存模型，JDK 5 开始使用：
* Java 内存模型是 JVM 的一种规范
* 定义了共享内存在多线程程序中读写操作的行为规范
* 屏蔽了各种硬件和操作系统的访问差异，保证了 Java 程序在各种平台下对内存的访问效果一致
* 解决并发问题采用的方式：限制处理器优化和使用内存屏障
* 增强了三个同步原语 sychronized、volatile、final 的内存语义
* 定义了 happens-before 规则

# 27. 在 Java 中，什么时候使用重载，什么时候使用重写？
* 重载是多态的集中体现。当需要以统一的方式处理不同的数据类型时，可以使用重载；
* 重写的使用是建立在继承关系上的，子类在继承父类的基础上需要增加新的功能时，可以使用重写；

# 28. 实例化对象有哪几种方式？
* new
* clone()
* 通过反射机制创建
* 通过序列化与反序列化

# 29. byte 类型 127 + 1 是多少？

byte的范围是 -128 ~ 127。字节长度为 8 位，最左边的是符号位，而 127 的二进制为 01111111，所以执行+1操作时，01111111 变为 10000000。

一个数如果为正，则它的原码、反码、补码相同；一个正数的补码，将其转化为十进制，可以直接转换。

已知一个负数的补码，将其转换为十进制数，步骤如下：

1. 先对各位取反；
2. 将其转换为十进制数；
3. 加上负号，再减去1；

例如 10000000，最高位是 1，是负数，对各位取反得 01111111，转换为十进制就是 127，加上负号得 -127，再减去 1 得 -128；





















