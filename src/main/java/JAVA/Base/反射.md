# 1. 类的加载
# 1.1 类加载阶段
* 加载：将 class 字节码文件的内容加载到内存中，并将这些静态的数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.class 对象。
* 链接：将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程。
  * 验证：确保加载的类信息符合 JVM 规范，没有安全方面的问题；
  * 准备：正式为类变量分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区内进行分配；
  * 解析：将虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程。
* 初始化：执行类构造器 <clinit>() 方法的过程。
  * 类构造器 <clinit>() 方法时编译器自动收集类中所有变量的赋值动作和静态代码块中的语句合并产生的，他是构造类信息的，不是构造该类对象的；
  * 当初始化一个类时，如果发现其父类还没有初始化，则先触发其父类的初始化；
  * 虚拟机会保证一个类的 <clinit>() 方法再在多线程环境中被正确的加锁和同步。  
    
## 1.2 类初始化
* 类的初始化是懒惰的，以下情况会引发初始化：
    * main 方法所在的类，总首先被初始化
    * 首次访问该类的静态变量或者静态方法时
    * 子类初始化时，若其父类还未被初始化，则会引发初始化
    * 子类访问父类的静态变量时，只会导致父类的初始化
    * Class.forName
    * new 会导致初始化
* 以下情况不会产生初始化：
    * 访问此类的 static final 静态常量(基本类型和字符串)
    * 执行类对象 .class 不会触发初始化
    * 创建该类对象的数组
    * 类加载器的 .loadClass 方法
    * Class.forName 的参数2 = false
    * 验证类是否被初始化，可以通过看该类的静态代码块中的语句是否执行来判断！

# 1.3 类加载器
在类加载阶段中的“通过一个类的全限定名来获取到描述该类的二进制字节流”。实现这个动作的代码被称为类加载器(classLoader)。

类加载器的分类：

| 名称 |	加载的类	| 说明 |
| --- | --- | --- |
| Bootstrap ClassLoader (启动类加载器) | JAVA_HOME/jre/lib | 无法直接访问 |
| Extension ClassLoader (扩展类加载器) | JAVA_HOME/jre/lib/ext | 上级为Bootstrap，显示为null |
| Application ClassLoader (应用类加载器) | classpath | 上级为Extension |
| 自定义类加载器 | 自定义 | 上级为Application |

# 2. 动态的创建对象执行方法

