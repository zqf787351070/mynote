# 1. 注解的简介与创建
Java 注解用于为 Java 代码提供元数据。注解在各种框架当中被广泛使用。

JDK 5 之后，Java 语言中就有了四种类型：类 Class、接口 Interface、枚举 Enum、注解 @interface，他们处于同一级别。

```java
public @interface MyAnnotation {
    
    // 定义静态属性
    String name = "ZQF";
    int age = 25;
    
    // 定义公共的抽象方法
    String code();
    
}
```

# 2. 元注解
元注解是可以注解在注解上的注解！即元注解是一种基本注解，可以应用到其他的注解上面。

元注解有`@Retention / @Documented / @Target / @Inherited / Repeatable`共 5 种

## 2.1 @Retention
当`@Retention`注解应用在其他注解上时，其解释说明了这个注解的生命周期。
* RetentionPolicy.SOURCE：注解只在源码阶段保留，在编译器进行编译时它将被忽视；
* RetentionPolicy.CLASS：注解只被保留到编译进行的时候，而不会被加载到 JVM 中；
* RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，会被加载进 JVM；

## 2.2 @Documented
这个元注解跟文档有关，他的作用时能够将注解中的元素包含到 Javadoc 当中。

## 2.3 @Target
该注解标明其作用的注解可以使用的范围。
* ElementType.ANNOTATION_TYPE：可以给一个注解进行注解
* ElementType.CONSTRUCTOR：可以给构造方法进行注解
* ElementType.FIELD：可以给属性进行注解
* ElementType.LOCAL_VARIABLE：可以给局部变量进行注解
* ElementType.METHOD：可以给方法进行注解
* ElementType.PACKAGE：可以给一个包进行注解
* ElementType.PARAMETER：可以给一个方法内的参数进行注解
* ElementType.TYPE：可以给一个类型进行注解，比如类、接口、枚举

## 2.4 @Inherited
如果一个类被`@Inherited`注解注解过的注解进行注解的话，那么如果它的子类没有应用任何注解的话，该子类便继承这个父类的注解。

## 2.5 @Repeatable
该注解是 Java 1.8 的新特性，被该注解作用的注解可以多次应用。下面看一个应用实例：
```java
@Person(role = "student")
@Person(role = "son")
@Person(role = "communist")
public class Demo01 {
    String name = "Leo Zhu";

    public static void main(String[] args) {
        Annotation[] annotations = Demo01.class.getAnnotations();
        System.out.println(annotations.length);
        Persons persons = (Persons) annotations[0];
        for (Person p: persons.value()) {
            System.out.println(p.role());
        }
        /**
         * 运行结果：
         * 1
         * student
         * son
         * communist
         */
    }
}

@Repeatable(Persons.class) // 括号里的内容相当于用来保存被注解内容的容器
@interface Person {
    String role() default "";
}

@Target(ElementType.TYPE) // 可以对类进行注解
@Retention(RetentionPolicy.RUNTIME) // 可以保留到程序运行时
@interface Persons {
    Person[] value();
}
```

# 3. 注解的属性
注解的属性也叫做成员变量，注解中只有成员变量，没有方法。
注解的成员将变量在注解的定义中以“无参方法”的形式来声明，其方法名即成员变量的名字，其返回值定义了该成员变量的类型。

```java
@testAnnotation01(id = 1, username = "zqf", password = "123")
public class Demo02 {
}

/**
 * 定义了一个拥有三个成员变量的注解 testAnnotation01，在使用的时候应该对其属性进行赋值
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface testAnnotation01 {
    int id();
    String username();
    String password();
}
```

需要注意的是，在注解中定义属性的时候，属性的类型必须是 8 种基本数据类型外加 类、接口、注解以及它们的数组。

注解中的属性可以有默认值，需要用 default 关键字指定。当属性存在默认值时，我们可以不为其赋值就直接使用。

```java
@testAnnotation02 // 不需要为属性赋值
public class Demo02 {
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface testAnnotation02 {
    String color() default "Red"; // 默认值为“Red”
    String name() default "flower"; // 默认值为“flower”
}
```

还有另外两种情况，在这不做实例演示：
* 注解的属性只有一个，可以直接在括号里赋值：`@testAnnotation("你好")`
* 注解不存在属性，直接使用

# 4. Java 预置的注解
## 4.1 @Override
标注子类需要重写的父类的方法。

## 4.2 @Deprecated
使用该注解后，表明被作用的方法或者类不推荐使用，但不代表不能使用。

有些时候项目工程太大，后续开发时我们需要重写一个方法，但是之前的方法还不能随意删除，因为它可能还在别处调用，此时就可以使用该注解。

```java
public class Demo03 {
    public static void main(String[] args) {
        Student student = new Student();
        student.studyWithPaper(); // 出现删除线指示
        student.studyWithComputer();
    }
}

class Student {
    @Deprecated
    public void studyWithPaper() {
        System.out.println("使用纸笔学习！");
    }
    
    public void studyWithComputer() {
        System.out.println("使用电脑学习！");
    }
}
```

## 4.3 @SuppressWarnings
组织警告。该注解会给编译器一条指令，告诉编译器对该注解作用下的代码内部的某些警告保持静默。

```java
@SuppressWarnings("deprecation") // 忽略 deprecation 相关的警告
public class Demo03 {
    public static void main(String[] args) {
        Student student = new Student();
        student.studyWithPaper(); // 删除线指示消失
        student.studyWithComputer();
    }
}

class Student {
    @Deprecated
    public void studyWithPaper() {
        System.out.println("使用纸笔学习！");
    }

    public void studyWithComputer() {
        System.out.println("使用电脑学习！");
    }
}
```

## 4.4 @SafeVarargs
参数安全类注解。其目的是提醒开发人员不要用参数做一些不安全的操作，它的存在会阻止编译器产生 unchecked 这样的警告。

在声明具有模糊类型（比如：泛型）的可变参数的构造函数或方法时，Java 编译器会报 unchecked 警告。
鉴于这种情况，如果开发者断定声明的构造函数和方法的主体不存在问题，可使用`@SafeVarargs`进行标记，这样 Java 编译器就不会报 unchecked 警告了！

## 4.5 @FunctionalInterface
Java 8 为函数式接口引入了一个新注解`@FunctionalInterface`，主要用于编译级错误检查，加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。
它主要用在 Lambda 表达式和方法引用上，如果某个接口被该注解作用，那么就可以使用 Lambda 表达式来表示该接口的一个实现。

```java
public class Demo04 {
    public static void main(String[] args) {
        GreetingService greetingService = message -> System.out.println("Hello " + message);
        greetingService.sayMessage("@FunctionalInterface"); // Hello @FunctionalInterface
    }
}

@FunctionalInterface
interface GreetingService {
    void sayMessage(String message);
}
```









































