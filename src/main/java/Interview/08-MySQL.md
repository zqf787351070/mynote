---
title: "08-MySQL"
sidebar: 'auto'
categories: 
 - "interview"
---

# 1. MySQL 索引有了解么？

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息，就像一本书的目录一样，可以**加快查询速度**。InnoDB 存储引擎的索引模型底层实现数据结构为**B+树**，所有数据都是存储在 B+ 树中的。

## 为什么底层数据结构是B+树而不是B树？

* B+树是B树的变种，**B+ 树的非叶子节点只用来保存索引，不存储数据，所有的数据都保存在叶子节点**；而**B 树的非叶子节点也会保存数据**。这样就使得 B+ 树的查询效率更加稳定，均为从根节点到叶子节点的路径。
* B+ 树的内部结点并**没有指向关键字具体信息的指针**，因此其内部结点相对 B 树更小，同样空间可以读入更多的节点，所以 B+ 树的**磁盘读写代价更低**。

## 聚簇索引和非聚簇索引有了解么？

* 聚簇索引 (主键索引) ：将数据存储与索引放在一起，并按照一定的顺序组织，找到了索引也就找到了数据，**其叶子结点就是数据节点**，数据的物理存放顺序与索引顺序一致，即索引相邻，对应的数据在磁盘上的存储也是相邻的。
* 非聚簇索引 (普通索引) ：叶子结点不存储数据，而是存储数据行地址，**其叶子结点仍然是索引节点**。即根据索引查找到数据行的位置后在根据地址去磁盘中进行查找，类似于书的目录。

![a775d0fc65ac8c07830cab54dec6905e.png](./image/a775d0fc65ac8c07830cab54dec6905e.png)

## MySQL 回表

* 如果语句是主键查询方式，则只需要搜索 主键索引树。
* 如果语句是普通索引查询方式，则需要先搜索普通索引树，得到其对应的主键值，再到主键索引树搜索一次。这个过程称为**回表**。

## 覆盖索引

如果在普通索引树上的查询已经直接提供了结果，不需要回表操作，这样的普通索引叫做覆盖索引。

覆盖索引的使用可以**显著提高查询效率**，是常见的 MySQL 性能优化手段。

## 索引最左前缀规则

在联合索引的情况下，不需要索引的全部定义，只要满足最左前缀，就可以利用索引来加快查询速度。

这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。

最左前缀原则的利用也可以**显著提高查询效率**，是常见的MySQL性能优化手段。

## 索引下推

在 MySQL5.6 之前，只能从根据最左前缀查询到 ID 开始一个个回表。到主键索引上找出数据行，再对比字段值。

MySQL5.6 引入的索引下推优化，（联合索引前提）可以在索引遍历过程中，**对索引中包含的其余字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，提升查询效率**。

## 哪些列上适合创建索引？创建索引的开销有哪些？

经常需要作为条件查询的列上适合创建索引，并且该列上也必须有一定的区分度。

创建索引需要维护，在插入数据的时候会重新维护各个索引树，对性能造成影响。

# 2. MySQL 常见的存储引擎有哪些？

MySQL中最常见的存储引擎有InnoDB和MyISAM，它们的主要区别如下：

* MyISAM不支持事务；InnoDB是事务类型的存储引擎。
* MyISAM只支持表级锁；InnoDB支持行级锁和表级锁，默认为行级锁。
* MyISAM引擎不支持外键；InnoDB支持外键。

## MySQL 逻辑架构

![785353ef2ce249b02ee6cf697954305c.png](./image/785353ef2ce249b02ee6cf697954305c.png)

由 MySQL 的逻辑架构图我们可以看出，逻辑架构包括 Server 层和存储引擎层。其中 Server 层包括连接器，分析器，优化器以及执行器；存储引擎层包括多种支持的存储引擎。各个逻辑部件的作用如下：

* 连接器：验证客户端权限，建立和断开MySQL连接
* 分析器：进行SQL语句的语法分析
* 优化器：选择索引，生成具体的SQL语句执行计划
* 执行器：操作存储引擎，执行SQL，返回执行结果
* 存储引擎层：各个不同的存储引擎都提供了一些读写接口来操作数据库

# 3. MySQL 中 where、group by、having 关键字？

这三个 MySQL 关键字作用可以总结如下：

* where 子句用来筛选 from 子句中指定的操作所产生的的行
* group by 子句用来分组where子句的输出
* having 子句用来从分组的结果中筛选行

## having 和 where 的区别

* 语法类似，where 搜索条件在进行**分组操作之前**应用；having 搜索条件在进行**分组操作之后**应用
* having 可以包含聚合函数 sum、avg、max等
* having 子句限制的是组，而不是行

# 4. MySQL的日志模块binlog和redo log有了解吗？

在 MySQL 的使用中，更新操作也是很频繁的，如果每一次更新操作都根据条件找到对应的记录，然后将记录更新，再写回磁盘，那么**IO 成本以及查找记录的成本都很高**。

所以，出现了日志模块，即我们的 update 更新操作是先写日志，在合适的时间才会去写磁盘，日志更新完毕就将执行结果返回给了客户端。

MySQL中的日志模块主要有 **redo log（重做日志）和 binlog（归档日志）**。

## redo log（重做日志）

redo log 是 **InnoDB 引擎**特有的日志模块，redo log 是**物理日志**，**记录了某个数据页上做了哪些修改**。InnoDB 的 redo log 是固定大小的，比如可以配置为一组4个文件，每个文件的大小是 1GB，那么 redo log 总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。

InnoDB 的 redo log 保证了数据库发生异常重启之后，之前提交的记录不会丢失，这个能力称 为crash-safe。

## binlog（归档日志）

binlog 是 **Server 层自带**的日志模块，binlog 是**逻辑日志**，**记录本次修改的原始逻辑，说白了就是SQL语句**。binlog 是追加写的形式，可以写多个文件，不会覆盖之前的日志。

通过 mysqlbinlog 可以解析查看 binlog 日志。

binlog 日志文件的格式：statement，row，mixed。

* **statement** 格式的 binlog 记录的是完整的 SQL 语句，优点是日志文件小，性能较好，缺点是准确性差，遇到SQL语句中有now()等函数会导致不准确
* **row** 格式的 binlog 中记录的是数据行的实际数据的变更，优点就是数据记录准确，缺点是日志文件较大。（业界推荐使用）
* **mixed** 格式的 binlog 是前面两者的混合模式

## 为什么 MySQL 会突然变慢一下？

当内存数据页和磁盘数据页内容不一致的时候，这个内存页就是“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，这个时候的内存页就是”干净页“。

更新数据库的时候是**先写日志**，当合适的机会（空闲）出现的时候才会更新磁盘。但是当 **redo log 写满了，要 flush 脏页**，也就是把内存里的数据写入磁盘，会导致 MySQL 执行速度突然变慢一瞬间。

# 5. MySQL事务有哪些特性？

| ACID | 含义 |
| --- | --- |
| Atomicity 原子性 | 事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败 |
| Consistent 一致性 | 在事务开始和完成时，数据都必须保持一致状态 |
| Isolation 隔离性 | 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立环境”下运行 |
| Durable 持久性 | 事务完成之后，对于数据的修改是永久的 |

## 如果不做控制，多个事务并发操作数据库会产生哪些问题？

| 问题 | 含义 |
| --- | --- |
| 丢失更新(Lost Update) | 当两个或多个事务选择同一行，最初事务修改的值会被后面事务修改的值覆盖 |
| 脏读(Dirty Reads) | 当一个事务正在访问数据，并且对数据进行了修改，而这个修改还没有提交到数据库中，此时另一个事务也访问到这个数据，并使用了这个数据 |
| 不可重复读(Non-Repetable Reads) | 一个事物在读取某些数据后的某个时间再次读取以前读过的数据，发现和之前不一样 |
| 幻读(Phantom Reads) | 一个事物按照相同的查询条件重新读取以前查询过的数据，却发现被其他事务插入了满足查询条件的新数据 |                             |

## MySQL 数据库事务的隔离级别有哪些？

| 隔离级别 | 丢失更新 | 脏读 | 不可重复读 | 幻读 |
| --- | --- | --- | --- | --- |
| Read uncommitted | × | ✔ | ✔ | ✔ |
| Read committeed | × | × | ✔ | ✔ |
| Repeatable read (默认) | × | × | × | ✔ |
| Serializable | × | × | × | × |

* **读未提交(Read Uncommitted)** ：允许脏读取。如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。
* **读已提交(Read Committed)** ：允许不可重复读取，但不允许脏读取。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。
* **可重复读(Repeatable Read)** ：禁止不可重复读取和脏读取，但是有时可能出现幻读。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。
* **序列化(Serializable)** ：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。

事务的隔离级别越高，对数据的完整性和一致性保证越佳，但是对并发操作的影响也越大。**MySQL 事务默认隔离级别是可重复读。**

# 6. MySQL中的锁机制

MySQL 数据库的锁分为**表级锁和行级锁**。从数据库的角度看，**行级锁又可以分为独占锁和共享锁**。

* **独占锁(Exclusive Lock)** ：独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。执行数据更新命令，即 **INSERT、UPDATE 或 DELETE** 命令时，MySQL 会自动使用独占锁。但当对象上有其它锁存在时，无法对其加独占锁。独占锁一直到事务结束才能被释放。
* **共享锁(Shared Lock)** ：共享锁顾名思义，那就是其锁定的资源可以被其它用户读取，但其它用户不能修改。

## MySQL 中的死锁

MySQL 中的死锁主要是多个事务使用行级锁对某行数据加锁造成的，MySQL 中的死锁主要是在说 InnoDB 存储引擎的死锁。

## 死锁如何解决？

* **业务逻辑**上解决死锁    
	* 指定锁的获取顺序
    * 大事务拆分成各个小事务
    * 在同一个事务中，一次锁定尽量多的资源，减少死锁概率
    * 给表建立合适的索引以及降低事务的隔离级别等
	
* **数据库设置**解决死锁    
	* 通过参数 innodb_lock_wait_timeout 根据实际业务场景来**设置超时时间**，InnoDB 引擎默认值是 50s。
    * 发起**死锁检测**，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑（默认是开启状态）。

## 行级锁什么时候会锁住整个表？

当不通过索引进行数据检索时，InnoDB 将会对表中的所有数据加锁

## 悲观锁与乐观锁

从程序员的角度看，数据库中的锁又可以分为**悲观锁和乐观锁**。

* **悲观锁**：利用数据库的锁机制实现，在整个数据处理过程中都加入了锁，以保持排他性。
* **乐观锁**：乐观锁可以利用 CAS 实现，在操作数据的时候进行一个比较，按照当前事务中的数据和数据库表中的该数据是否一致来决定是否要执行本次操作。

### 乐观锁的 ABA 问题有了解吗？如何解决？

ABA问题可以通过基于**数据版本（Version）记录机制**来解决。也就是为数据增加一个版本标识。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。根据当前事务的数据版本号和数据库中数据的版本号对比来决定是否更新数据。

# 7. 有 SQL 优化或者 MySQL 故障排查经历吗？

通过 **explain** 查看当前SQL语句的执行情况。

# 8. MySQL建表的约束条件有哪些？

* **主键约束(Primay Key Coustraint)** ：唯一性，非空性
* **唯一约束(Unique Counstraint)** ：唯一性，可以空，但只能有一个
* **检查约束(Check Counstraint)** ：对该列数据的范围、格式的限制
* **默认约束(Default Counstraint)** ：该数据的默认值
* **外键约束(Foreign Key Counstraint)** ：需要建立两表间的关系并引用主表的列

# 9. limit 分页查询使用方式

语句：select * from [表名] limit [偏移值],[每页数据行数];

**第 n 页的偏移值 = (n - 1) * 每页数据行数**

limit 在所有查询条件最后使用

# 10. 主键自增长设置方式

auto_increment

# 11. SQL语句的优化有哪些？

* 避免索引失效
* 尽量避免使用前导模糊查询
* 避免不必要的类型转换
* 增加查询范围的限制
* 规范所有关键字的书写
* ......

# 12. order by 是怎么工作的？

全字段排序 和 rowid排序
[详情参考](https://blog.csdn.net/a1047003619/article/details/110457301)

