---
title: "09-Redis"
sidebar: 'auto'
categories: 
 - "interview"
---

# 1. Redis 有了解么？

答：redis（Remote Dictionary Server远程字典服务）是一款高性能的分布式**内存数据库**，是**基于内存运行并支持持久化的 NoSQL 数据库**。

Redis 支持丰富的数据类型，支持数据持久化、事务、主从复制、哨兵模式......

## Redis 与 memcached 相比有什么优势？

* 数据类型：memcached 所有值均是简单字符串；redis 支持更加丰富的数据类型
* 数据备份：redis 支持数据备份
* 运行速度：redis 速度比 memcached 快，并且支持数据持久化
* 底层模型：底层使用模型不同，redis 自己构建了 VM 管理机制
* value大小：value 大小不同，redis 可达 512M；memcached 只有 1M

## Redis 支持哪些数据类型？应用场景有哪些？

* **String**    
	* 字符串 value 的最大值为 512M
    * 常用来做一些计数功能的缓存

* **List**    
	* 按插入顺序排序，可以添加一个元素到列表的头部或尾部
    * 底层为一个链表
    * 可以实现简单消息队列功能，做基于 redis 的分页功能

* **Set**    
	* 字符串类型的无序集合
    * 可用来全局去重

* **Zset**    
	* 字符串类型的有序集合，每一个元素配有一个 score 来保持顺序
    * 可以用来做排行榜应用或者进行范围查找

* **Hash**    
	* 键值对集合
    * 用来存放对象
	
## Redis 配置文件有了解么？

答：常用模块如下

* **NETWORK**：配置 redis 服务器地址，端口，超时时间等
* **GENERAL**：配置日志文件的路径和日志级别等
* **SNAPSHOTTING**：RDB 持久化配置信息
* **REPLICATION**：redis 集群配置信息
* **MEMORY MANAGEMENT**：内存管理，包括数据过期删除策略等信息的设置
* **APPEND ONLY MODE**：AOF 持久化配置信息

# 2. Redis 是单线程的么？为什么执行速度这么快？

答：

redis 是**单线程**的。redis 的单线程指网络请求模块使用了一个线程，所以不需要考虑并发安全性。

但是对于需要依赖多个操作的复合操作来说，可能需要分布式锁。

redis 执行速度快基于以下原因：

* 基于内存实现，完全内存计算
* 单线程操作，避免上下文切换
* 多路 I/O 复用的线程模型，实现了一个线程监控多个 IO 流，及时响应请求
* redis 对外部依赖小，属于轻量级的内存数据库

# 3. 使用 Redis 可能出现的问题

答：**缓存雪崩、缓存击穿、缓存穿透、数据库和缓存的双写一致性问题**

## 缓存雪崩

概述：缓存雪崩指缓存在同一时间大面积的失效，而此时又有大量的请求发送到数据库上，导致数据库连接异常。

解决方法：可以给缓存设置不同的缓存时间，更新数据使用互斥锁，或者通过双缓存避免缓存雪崩。

## 缓存击穿

概述：redis 中存储的是热点数据，当高并发请求访问 redis 中的热点数据时，若 redis 中的数据过期了，就会造成缓存击穿现象，请求穿过缓存直接打在了数据库上。

解决方法：使用互斥锁，只让一个请求去load DB，成功之后重新写缓存。而其他的请求没有获取到互斥锁，可以尝试重新获取缓存中的数据。

## 缓存穿透

概述：故意去请求缓存中不存在的数据，导致请求全部打在数据库上，导致数据库异常。

解决方法：可以使用互斥锁，或者无论是否取到结果都将结果存入缓存，还可以使用有效的机制（例如布隆过滤器）来拦截不合法的 key 值。

## 数据库和缓存的双写一致性问题

概述：在高并发请求下容易导致数据不一致的问题，若业务需要强一致性，建议不使用缓存。在数据库中和缓存数据的删除或者写入过程中，如果有失败的情况，会导致数据的不一致。

解决方法：

* **双删延迟**：可以先删除缓存数据，再更新数据库。最后再间隔固定的时间去再次删除缓存。
* **更新数据库产生的binlog订阅（使用canal）**：如果上次删除缓存失败，则将有变化的 key 记录下来，并且尝试去不断的删除缓存。

# 4. Redis 的持久化方式有哪些？

答：**RDB 和 AOF**

## RDB（全量持久化）

**触发方式**

* 自动触发：在配置文件中可以配置执行多少次 save 就自动触发持久化
* 手动触发：通过 bgsave 指令，可以 fork 一个子进程负责异步生成快照

**快照恢复**

将备份文件更名为 dump.rdb 并移动到 redis 安装目录，redis 在启动时会自动加载快照文件数据到内存。

**优缺点分析**

* RDB 持久化方式存在数据丢失，因为其不是实时的实现持久化（会丢失最后一次持久化之后的数据）。
* 每一次执行 bgsave 都需要 fork 一个子进程，属于重量级操作，频繁执行的成本过高，会影响系统性能。自动触发同样存在部分数据丢失的问题。
* 对数据准确性要求不高且恢复大数据集时，RDB 速度快于 AOF。

## AOF（增量持久化）

AOF 需要在配置文件中手动开启。

**AOF 日志重写**

* 随着服务器的运行，AOF 文件会越来越大，可以通过 AOF 重写来控制其大小。
* AOF 重写会首先读取数据库中现有的键值对状态，然后根据类型使用一条命令来代替前面对键值对操作的多条命令，达到压缩大小的效果。
* 使用 bgrewriteaof 命令实现 AOF 重写。

**AOF 重写缓存区**

redis 是单线程工作，当AOF文件较大时重写时间会比较长，在重写 AOF 期间，redis将长时间无法处理客户端请求。为了解决这个问题，可以将 AOF 重写程序放到子进程中执行。

优点：

* 子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理其它客户端请求。
* 子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。

**子进程 AOF 重写导致的问题**

子进程在进行 AOF 重写期间，服务器进程依然可以处理其它客户端请求，这就会导致数据库状态已经发生了改变，使得当前数据库数据状态和重写后的 AOF 文件中的数据不一致。

解决方法：

* redis 服务器设置了一个 AOF 重写缓冲区。这个缓冲区在创建子进程后开始使用，当redis服务器执行一个客户端的写请求命令，之后将这个写命令也发送到 AOF 重写缓冲区。
* 当子进程完成 AOF 日志重写之后，给父进程发送信号，父进程接收此信号后，将 AOF 重写缓冲区的内容写到新的 AOF 文件中，保持数据的一致性。

**优缺点分析**
* AOF 可以做到秒级持久化，使用追加写的方式来写入，可读性强。且当文件毁坏时，还可以使用命令进行文件修复。
* 相比 RDB，同样的数据量的情况下 AOF 文件体积更大。在 redis 负载较高时，秒级更新 AOF 文件会影响性能。

## 持久化策略选择

* AOF更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢也更加完整。
* RDB持久化，安全性较差，它是正常时期数据备份及 master-slave数据同步的最佳手段，文件尺寸较小并且恢复速度较快。

# 5. Redis 数据的过期回收策略与内存淘汰机制

## 过期回收策略

redis 中的数据过期回收策略使用了定期删除和惰性删除相结合的方式。

* **定期删除**：redis 每隔一段时间去抽查一定量的数据判断其是否过期，若过期则进行删除。

* **惰性删除**：在获取一个 key 时，redis 会检查这个 key 是否已经过期，若过期则会进行删除操作。

## 内存淘汰机制

在配置文件中，我们可以对内存淘汰机制进行配置。当内存使用达到最大值时，redis 可以使用的清除策略如下：

* **volatile-lru**：利用 LRU 算法移除设置过过期时间的 key（LRU：最近使用，least Recently Used）
* **allkeys-lru**：利用 LRU 算法移除任何 key
* **volatile-random**：移除设置过过期时间的随机 key
* **allkeys-random**：移除随机 key
* **volatile-ttl**：移除即将过期的 key
* **noeviction**：不移除任何 key，只是返回一个写错误，为默认选项

# 6. Redis 主从复制

答：

当项目较大时，可以使用**主从架构 Master/Slave 机制**。其中 Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置自动同步到从机 Slave 节点。

主从复制的原理包括**旧版同步**和**命令传播**，其代价是系统复制较重是会导致主从延迟，且根据 CAP 理论，**无法同时保证高可用性和一致性**。

# 7. Redis 对事务的支持

答：redis 事务有三大特性：**单独的隔离操作、没有隔离级别的概念、不保证原子性**。

* **单独的隔离操作**：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
* **没有隔离级别的概念**：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题
* **不保证原子性**：redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚

## 事务操作的相关命令

| 命令 | 描述 |
| --- | --- |
| discard | 取消事务，放弃执行事务块内的所有命令 |
| exec | 执行事务块内的所有命令 |
| multi | 标记一个事务块的开始 |
| unwatch | 取消watch命令对所有key的监视 |
| watch key [key...] | 监视一个或者多个key，如果事务执行之前这些key被其他命令所改动，那么事务将会被打断 |

# 8. Redis 如何实现分布式锁？如何加锁解锁？



# 9. Redis 的哨兵模式

答：

哨兵模式即使用一组 sentinel 监控多个 master，是反客为主的自动版，能够在后台监控主库的运行状态，如果主库宕机则采取投票的方式自动选取一个从库转换为主库。

使用：

1. 新建 sentinel.conf 文件，并配置内容 `sentinel monitor <master-group-name> <ip> <port> <quorum>`

2. 使用**redis-server sentinel.conf --sentinel**命令启动哨兵

