---
title: "牛客高频编程"
sidebar: 'auto'
categories:
- "interview"
---

# NC78.反转链表
![NC78.png](./picture/NC78.png)

解析：采用递归算法

参考代码：
```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode newHead = ReverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```

# NC4. 判断链表中是否有环
![NC4.png](./picture/NC4.png)

解析：使用快慢指针，若快慢指针能相遇则证明有环

参考代码：
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null) return false;
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast)
                return true;
        }
        return false;
    }
}
```

# NC76. 用两个栈实现队列
![NC76.png](./picture/NC76.png)

解析：借助辅助栈

参考代码：
```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        while (!stack1.isEmpty())
            stack2.push(stack1.pop());
        int res = stack2.pop();
        while (!stack2.isEmpty())
            stack1.push(stack2.pop());
        return res;
    }
}
```

# NC105。含重复数的二分查找
![NC105.png](./picture/NC105.png)

解析：
1. 思路1：按照无重复数的二分查找先找到一个符合的位置，然后向左找到第一个目标数；
2. 思路2：修改二分查找的思路实现，具体看代码；

思路2参考代码：
```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 如果目标值存在返回下标，否则返回 -1
     * @param nums int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] nums, int target) {
        if (nums == null || nums.length == 0) return -1;
        return binarySearch(0, nums.length - 1, target, nums);
    }
    public int binarySearch(int left, int right, int target, int[] nums) {
        if (left == right) {
            if (nums[left] == target)
                return left;
            else
                return -1;
        }
        int midIdx = (left + right) >> 1;
        int midVal = nums[midIdx];
        if (midVal >= target)
            return binarySearch(left, midIdx, target, nums);
        else 
            return binarySearch(midIdx + 1, right, target, nums);
    }
}
```

# NC15. 求二叉树的层序遍历
![NC15.png](./picture/NC15.png)

解析：使用队列辅助完成二叉树的层序遍历

参考代码：
```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @return int整型ArrayList<ArrayList<>>
     */
    public ArrayList<ArrayList<Integer>> levelOrder (TreeNode root) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if (root != null)
            queue.offer(root);
        while (!queue.isEmpty()) {
            ArrayList<Integer> temp = new ArrayList<>();
            int length = queue.size();
            for (int i = 0; i < length; i++) {
                TreeNode node = queue.poll();
                temp.add(node.val);
                if (node.left != null)
                    queue.offer(node.left);
                if (node.right != null)
                    queue.offer(node.right);
            }
            res.add(temp);
        }
        return res;
    }
}
```

# NC68. 跳台阶
![NC68.png](./picture/NC68.png)

解析：斐波那契数列，使用动态规划求解

参考代码：
```java
public class Solution {
    public int jumpFloor(int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i < dp.length; i++)
            dp[i] = dp[i - 1] + dp[i - 2];
        return dp[target];
    }
}
```

# NC41. 最长无重复子数组
![NC41.png](./picture/NC41.png)

解析：利用队列的特性，若发现重复元素，则将队列至重复元素处的元素全部删除

参考代码：
```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxLength (int[] arr) {
        LinkedList<Integer> list = new LinkedList<>();
        int res = 0, index = 0;
        for (int i = 0; i < arr.length; i ++) {
            if (list.contains(arr[i])) {
                index = list.indexOf(arr[i]);
                while (index >= 0) {
                    list.removeFirst();
                    index += -1;
                }
            }
            list.addLast(arr[i]);
            res = Math.max(res, list.size());
        }
        return res;
    }
}
```

# NC102. 在二叉树中寻找两个节点的最近公共祖先
![NC102,png](./picture/NC102.png)

解析：采用递归算法

* 终止条件：
  * 当越过叶子结点，则直接返回 null
  * 当 root = p 或 q，则直接返回 root
* 递推：
  * 递归左子节点 left
  * 递归右子节点 right
* 返回值：
  * 当 left 和 right 同时为空 ：说明 root 的左 / 右子树中都不包含 p,q ，返回 null
  * 当 left 和 right 同时不为空 ：说明 p, q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root
  * 当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right
  * 当 left 不为空 ， right 为空

参考代码：
```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        TreeNode ancestor = lowestCommonAncestor2(root, o1, o2);
        return ancestor.val;
    }
    public TreeNode lowestCommonAncestor2 (TreeNode root, int o1, int o2) {
        if (root == null || root.val == o1 || root.val == o2)
            return root;
        TreeNode left = lowestCommonAncestor2(root.left, o1, o2);
        TreeNode right = lowestCommonAncestor2(root.right, o1, o2);
        if (left == null && right == null)
            return null;
        if (left == null)
            return right;
        if (right == null)
            return left;
        return root;
    }
}
```

# NC119. 最小的 k 个数
![NC119.png](./picture/NC119.png)

解析：冒泡排序的反向思路--“沉底排序”

实现代码：
```java
import java.util.ArrayList;

public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> res = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            for (int j = input.length - 1; j > 0; j--) {
                if (input[j] < input[j - 1]) {
                    int temp = input[j];
                    input[j] = input[j - 1];
                    input[j - 1] = temp;
                }
            }
            res.add(input[i]);
        }
        return res;
    }
}
```

# NC22. 合并两个有序的数组
![NC22.png](./picture/NC22.png)

解析：双指针，从后向前，避免占用额外的空间

参考代码：
```java
public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int i = m - 1, j = n - 1, index = m + n - 1;
        while (index >= 0) {
            if (i < 0) {
                A[index] = B[j];
                index--;
                j--;
                continue;
            }
            if (j < 0) {
                A[index] = A[i];
                index--;
                i--;
                continue;
            }
            if (A[i] > B[j]) {
                A[index] = A[i];
                i--;
            } else {
                A[index] = B[j];
                j--;
            }
            index--;
        }
    }
}
```

# NC45. 二叉树的前序、中序、后序遍历
![NC45.png](./picture/NC45.png)

解析：DFS求解

参考代码：
```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 the root of binary tree
     * @return int整型二维数组
     */
    public int[][] threeOrders (TreeNode root) {
        List<Integer> preOrderList = new ArrayList<>();
        List<Integer> midOrderList = new ArrayList<>();
        List<Integer> postOrderList = new ArrayList<>();
        preOrder(root, preOrderList);
        midOrder(root, midOrderList);
        postOrder(root, postOrderList);
        int[][] res = new int[3][preOrderList.size()];
        res[0] = trans(preOrderList);
        res[1] = trans(midOrderList);
        res[2] = trans(postOrderList);
        return res;
    }
    public void preOrder (TreeNode root, List<Integer> list) {
        if (root == null) return;
        list.add(root.val);
        preOrder(root.left, list);
        preOrder(root.right, list);
    }
    public void midOrder (TreeNode root, List<Integer> list) {
        if (root == null) return;
        midOrder(root.left, list);
        list.add(root.val);
        midOrder(root.right, list);
    }
    public void postOrder (TreeNode root, List<Integer> list) {
        if (root == null) return;
        postOrder(root.left, list);
        postOrder(root.right, list);
        list.add(root.val);
    }
    public int[] trans (List<Integer> list) {
        int[] res = new int[list.size()];
        for (int i = 0; i < res.length; i++) {
            res[i] = list.get(i);
        }
        return res;
    }
}
```

# NC88。寻找第K大的数
![NC88.png](./picture/NC88.png)

解析：采用快排求解

参考代码：
```java
import java.util.*;

public class Solution {
    public int findKth(int[] a, int n, int K) {
        quickSort(0, n - 1, a);
        return a[n - K];
    }
    public void quickSort(int left, int right, int[] arr) {
        int l = left;
        int r = right;
        int midVal = arr[(left + right) >> 1];
        while (l < r) {
            while (arr[l] < midVal) l++;
            while (arr[r] > midVal) r--;
            if (l >= r) break;
            int temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;
            if (arr[l] == midVal) r--;
            if (arr[r] == midVal) l++;
        }
        if (l == r) {
            l++;
            r--;
        }
        if (left < r) quickSort(left, r, arr);
        if (l < right) quickSort(l, right, arr);
    }
}
```

# NC19. 子数组的最大累加和问题
![NC19.png](./picture/NC19.png)

解析：采用动态规划求解

参考代码：
```java
import java.util.*;


public class Solution {
  /**
   * max sum of the subarray
   * @param arr int整型一维数组 the array
   * @return int整型
   */
  public int maxsumofSubarray (int[] arr) {
    int[] dp = new int[arr.length];
    dp[0] = arr[0];
    int res = dp[0];
    for (int i = 1; i < dp.length; i++) {
      dp[i] = Math.max(dp[i - 1] + arr[i], arr[i]);
      res = Math.max(res, dp[i]);
    }
    return res;
  }
}
```

# NC103. 反转字符串
![NC103.png](./picture/NC103.png)

解析：借助 StringBuilder 类的 reverse() 方法实现

参考代码：
```java
import java.util.*;


public class Solution {
    /**
     * 反转字符串
     * @param str string字符串 
     * @return string字符串
     */
    public String solve (String str) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < str.length(); i++)
            builder.append(str.charAt(i));
        builder.reverse();
        return builder.toString();
    }
}
```

# NC17. 最长子回文串
![NC17.png](./picture/NC17.png)

解析：动态规划的思想，采用动态规划数组`boolean[][] dp`来记录两个字符之间能否形成回文串

参考代码：
```java
import java.util.*;

public class Solution {
    public int getLongestPalindrome(String A, int n) {
        boolean[][] dp = new boolean[n][n];
        int res = 0;
        for (int len = 0; len < n; len ++) {
            for (int start = 0; start < n - len; start++) {
                int end = start + len;
                if (A.charAt(start) == A.charAt(end)) {
                    if (len == 0 || len == 1)
                        dp[start][end] = true;
                    else
                        dp[start][end] = dp[start + 1][end - 1];
                    if (dp[start][end])
                        res = Math.max(res, len + 1);
                }
            }
        }
        return res;
    }
}
```

# NC8. 二叉树根节点到叶子节点的和为定值的路径
![NV8.png](./picture/NC8.png)

解析：深度优先遍历 DFS 求解

参考代码：
```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param sum int整型 
     * @return int整型ArrayList<ArrayList<>>
     */
    public ArrayList<ArrayList<Integer>> pathSum (TreeNode root, int sum) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        dfs(root, sum, new ArrayList<Integer>(), res);
        return res;
    }
    public void dfs(TreeNode root, int target, ArrayList<Integer> list, ArrayList<ArrayList<Integer>> res) {
        if (root == null) return;
        list.add(root.val);
        if (root.left == null && root.right == null && (target - root.val) == 0)
            res.add(list);
        dfs(root.left, target - root.val, new ArrayList<Integer>(list), res);
        dfs(root.right, target - root.val, new ArrayList<Integer>(list), res);
    }
}
```

# NC40. 两个链表生成相加链表
![NC40.png](./picture/NC40.png)

解析：借助栈实现

参考代码：
```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    public ListNode addInList (ListNode head1, ListNode head2) {
        Stack<Integer> stack1 = prepare(head1);
        Stack<Integer> stack2 = prepare(head2);
        ListNode head = null, cur = null;
        int x = 0, y = 0, sum = 0;
        while (!stack1.isEmpty() || !stack2.isEmpty() || y > 0) {
            if (!stack1.isEmpty() && !stack2.isEmpty()) {
                sum = stack1.pop() + stack2.pop();
            } else if (stack1.isEmpty() && !stack2.isEmpty()) {
                sum = stack2.pop();
            } else if (stack2.isEmpty() && !stack1.isEmpty()) {
                sum = stack1.pop();
            }
            x = (sum + y) % 10;
            y = (sum + y) >= 10 ? 1 : 0;
            cur = new ListNode(x);
            cur.next = head;
            head = cur;
            sum = 0;
        }
        return head;
    }
    public Stack<Integer> prepare (ListNode head) {
        Stack<Integer> stack = new Stack<>();
        ListNode cur = head;
        while (cur != null) {
            stack.push(cur.val);
            cur = cur.next;
        }
        return stack;
    }
}
```

# NC7. 买卖股票的最好时机
![NC7.png](./picture/NC7.png)

解析：遍历数组，维护一个最大利益 res 和最小价格 min。
* 如果当天的股票价格低于最小价格 min，则将最小价格置为当天的股票价格；
* 如果当天的股票价格高于最小价格 min，则计算当天卖出的收益，并与最大收益作比较，取两者中较大的作为结果；

参考代码：
```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param prices int整型一维数组 
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        int min = prices[0], res = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] < min)
                min = prices[i];
            else
                res = Math.max(res, prices[i] - min);
        }
        return res;
    }
}
```

# NC1. 大数加法
![NC1.png](./picture/NC1.png)

解析：采用与 NC40 相同的思路求解，只不过该题不需要借助辅助栈，采用双指针即可。

参考代码：
```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算两个数之和
     * @param s string字符串 表示第一个整数
     * @param t string字符串 表示第二个整数
     * @return string字符串
     */
    public String solve (String s, String t) {
        StringBuilder builder = new StringBuilder();
        int i = s.length() - 1, j = t.length() - 1;
        int x = 0, y = 0, sum = 0;
        while ( i >= 0 || j >=0 || y > 0) {
            if (i >= 0 && j >= 0) {
                sum = s.charAt(i) - '0' + t.charAt(j) - '0';
            } else if (i >= 0 && j < 0) {
                sum = s.charAt(i) - '0';
            } else if (j >= 0 && i < 0) {
                sum = t.charAt(j) - '0';
            }
            x = (sum + y) % 10;
            y = (sum + y) >= 10 ? 1 : 0;
            builder.append(x + "");
            sum = 0;
            i += -1;
            j += -1;
        }
        return builder.reverse().toString();
    }
}
```

# NC3. 链表中环的入口节点
![NC3.png](./picture/NC3.png)

解析：关于链表的两个结论：
* 设置快慢指针，如果链表有环，则快慢指针一定相遇；
* 两个指针分别从头节点和相遇节点处出发，每次走一步，则两个指针一定相遇于环入口；

结论 2 证明：
* 设链表头到环入口的长度为 a；
* 设环入口到相遇点的距离为 b；
* 设相遇点到环入口的距离为 c；

相遇时，快指针的路程 = `a + k(b + c) + b`，其中`k >= 1`；慢指针路程 = `a + b`。快指针的路程是慢指针的两倍，则有`2(a + b) = a + k(b + c) + b`。
化简得 `a = (k - 1)(b + c) + c`，即`链表头到环入口的距离 = 相遇点到环入口的距离 + (k - 1)圈环长度`。
因为`k >= 1`，所以所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。

参考代码：
```java
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead) {
        ListNode slow = pHead, fast = pHead;
        ListNode meet = null;
        while (slow != null && fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast){
                meet = slow;
                break;
            }
        }
        if (meet == null)
            return null;
        while (meet != pHead) {
            meet = meet.next;
            pHead = pHead.next;
        }
        return pHead;
    }
}
```

# NC156. 数组中只出现一次的数(其他数出现k次)
![NC156.png](./picture/NC156.png)

解析：采用位运算的思想，每一次计算数组中的数的二进制对应位上 1 的个数，记录在数组中。如果某一位上 1 的个数对 K 取余不为零，说明出现一次的数的二进制的对应位为 1，恢复该数，输出即可；

本题也可以采用辅助 hashMap 的方法，key 存对应数，value 存 true/false，代码略。

参考代码：
```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param arr int一维数组 
     * @param k int 
     * @return int
     */
    public int foundOnceNumber (int[] arr, int k) {
        int[] binarySum = new int[32];
        for (int i = 0; i < 32; i++) {
            int sum = 0;
            for (int num: arr) {
                sum += (num >> i & 1);
            }
            binarySum[i] = sum;
        }
        int res = 0;
        for (int i = 0; i < 32; i++) {
            if (binarySum[i] % k != 0)
                res += (1 << i);
        }
        return res;
    }
}
```

# NC128. 接雨水问题
![NC128.png](./picture/NC128.png)

解析：采用双指针求解
* 选取左右指针中较小的值作为临时高度 temp
* 当左指针小于右指针时：
  * 若左指针对应高度小于右指针对应高度，则左指针右移，判断此时左指针指示高度和 temp 的大小
    * 若此时左指针指示高度低于 temp，则证明可以蓄水，更新 res
    * 否则则重新选取临时高度 temp
  * 若左指针对应高度大于等于右指针对应高度，则右指针左移，判断此时右指针指示高度和 temp 的大小
    * 若此时右指针指示高度低于 temp，则证明可以蓄水，更新 res
    * 否则则重新选取临时高度 temp
  
参考代码：
```java
import java.util.*;


public class Solution {
    /**
     * max water
     * @param arr int整型一维数组 the array
     * @return long长整型
     */
    public long maxWater (int[] arr) {
        if (arr == null || arr.length <= 2)
            return 0;
        int left = 0, right = arr.length - 1;
        int temp = Math.min(arr[left], arr[right]);
        long res = 0;
        while (left < right) {
            if (arr[left] < arr[right]) {
                left++;
                if (arr[left] < temp)
                    res += (temp - arr[left]);
                else
                    temp = Math.min(arr[left], arr[right]);
            } else {
                right--;
                if (arr[right] < temp) 
                    res += (temp - arr[right]);
                else
                    temp = Math.min(arr[left], arr[right]);
            }
        }
        return res;
    }
}
```
















